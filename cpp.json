{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.	
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"starting template": {
	"prefix": "zx",
	"body": [
		"#include <bits/stdc++.h>",
		"#include <ext/pb_ds/assoc_container.hpp>",
		"#include <ext/pb_ds/tree_policy.hpp>",
		"",
		"using namespace __gnu_pbds;",
		"template <typename T>",
		"using ordered_set = tree<T, null_type, std::less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
		"",
		"using namespace std;",
		"",
		"typedef long long ll;",
		"typedef long double ld;",
		"typedef pair<int, int> ii;",
		"",
		"// Global Variables & Structures",
		"",
		"",
		"",
		"// Functions",
		"",
		"void solve(int test_id) {",
		"    $0",
		"}",
		"",
		"int main(void) {",
		"    ios_base::sync_with_stdio(0); cin.tie(0);",
		"    cout << fixed;",
		"",
		"    int tests = 1;",
		"    // cin >> tests; ",
		"    for (int test = 0; test < tests; test++) {",
		"        solve(test);",
		"    }",
		"}",
		""
	],
	"description": "starting template"
	},
	  "kmp pattern searching": {
		"prefix": "kmp",
		"body": [
		  "// kmp pattern searching - O(n + m)",
		  "void kmp(const string &txt, const string &pat) {",
		  "    int n = txt.size(), m = pat.size();",
		  "    vector<int> lps(m, 0);",
		  "    int len = 0;",
		  "    for (int i = 1; i < m; i++) {",
		  "        // building lps array (longest proper prefix-suffix)",
		  "        while (len > 0 && pat[i] != pat[len]) {",
		  "            len = lps[len - 1];",
		  "        }",
		  "        if (pat[i] == pat[len]) {",
		  "            len++;",
		  "        }",
		  "        lps[i] = len;",
		  "    }",
		  "    int i = 0, j = 0;",
		  "    for (int i = 0; i < n; i++) {",
		  "        // searching for pattern",
		  "        while (j > 0 && txt[i] != pat[j]) {",
		  "            j = lps[j - 1];",
		  "        }",
		  "        if (txt[i] == pat[j]) {",
		  "            j++;",
		  "        }",
		  "        if (j == m) {",
		  "            cout << i - m + 1 << '\\n';",
		  "            j = lps[j - 1];",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "kmp pattern searching"
	  },
	"binary form": {
	"prefix": "binary form",
	"body": [
		"template <typename T>",
		"string binaryform(T n) {",
		"    string s;",
		"    while (n) {",
		"        s += to_string(n % 2);",
		"        n /= 2;",
		"    }",
		"    reverse(s.begin(), s.end());",
		"    return s;",
		"}"
	],
	"description": "binary form"
	},
	"submasking": {
	"prefix": "submasking",
	"body": [
		"for (int submask = mask; submask > 0; submask = ((submask - 1) & mask)) {",
		"",
		"}",
		"int finalsubmask = 0;"
	],
	"description": "submasking"
	},
	"Graph": {
	"prefix": "Graph",
	"body": [
		"// T2 is the adjacency list type, can be either vector<pair<int,T>> or set<pair<int,T>>",
		"template <typename T = long long, typename T2 = vector<pair<int, T>>> ",
		"class Graph { // assumes no self loops, repeat edges",
		"    int n, m;",
		"    vector<T2> adj;",
		"    vector<T2> radj; // reverse adjacency list/set. For Kosaraju algo (Scc)",
		"    vector<int> vis;",
		"    bool need_dfs_stack;",
		"    bool calc_ind, calc_outd;",
		"    bool need_rev_edges; // need reverse edges or not (for Kosaraju)",
		"    bool doing_dfs_finishorder, doing_dfs_components; // dfs flags",
		"    bool is_undirected;",
		"    vector<int> indegree; // for Kahn's algorithm, Eulerian path/cycle",
		"    vector<int> outdegree;",
		"public:",
		"    int contains_cycle; // cycle detected automatically whenever a dfs is run",
		"    int is_bipartite; // run function bipartite_check()",
		"    vector<T> dist; // for djikstra",
		"    int components;",
		"    vector<int> component; // component no. of each node",
		"    vector<int> bi_color; // color for bipartite check",
		"    vector<int> dfs_stack;",
		"    vector<int> topo_order; // call function is_dag()",
		"    vector<int> eulerian_path;",
		"    vector<int> finish_order;",
		"    Graph(int x, bool undirected = 0, bool calc_indegrees = 0, bool calc_outdegrees = 0, bool rev_edges = 0) {",
		"        static_assert(is_same<T2, vector<pair<int, T>>>::value || is_same<T2, set<pair<int, T>>>::value,",
		"            \"Error: Invalid adjacency list type. Expected vector<pair<int, T>> or set<pair<int, T>>.\");",
		"        is_undirected = undirected;",
		"        n = x;",
		"        adj.resize(n);",
		"        for (int i = 0; i < n; i++) adj[i].clear();",
		"        m = 0;",
		"        vis.clear();",
		"        dist.clear();",
		"        component.clear();",
		"        bi_color.clear();",
		"        indegree.clear();",
		"        outdegree.clear();",
		"        topo_order.clear();",
		"        eulerian_path.clear();",
		"        radj.clear();",
		"        contains_cycle = -1;",
		"        is_bipartite = -1;",
		"        components = -1;",
		"        need_dfs_stack = 0;",
		"        if (calc_ind = calc_indegrees) indegree.assign(n, 0);",
		"        if (calc_outd = calc_outdegrees) outdegree.assign(n, 0);",
		"        if (need_rev_edges = rev_edges) {",
		"            radj.resize(n);        ",
		"            for (int i = 0; i < n; i++) radj[i].clear();",
		"        }",
		"    }",
		"    void add_edge(int u, int v, T w = 1) {",
		"        assert(u >= 0 && u < n && v >= 0 && v < n);",
		"        if constexpr (is_same<T2, vector<pair<int, T>>>::value) { // compile time executed if -> if constexpr",
		"            adj[u].push_back({v, w}); // assuming directed graph",
		"            if (is_undirected) adj[v].push_back({u, w});",
		"            if (need_rev_edges) radj[v].push_back({u, w});",
		"        }",
		"        else {",
		"            adj[u].insert({v, w});",
		"            if (is_undirected) adj[v].insert({u, w});",
		"            if (need_rev_edges) radj[v].insert({u, w});",
		"        }",
		"        m++;",
		"        if (calc_ind) indegree[v]++;",
		"        if (calc_outd) outdegree[u]++;",
		"    }",
		"    void _dfs(int u, int p, int comp_num) {",
		"        vis[u] = 1;",
		"        if (doing_dfs_components) component[u] = comp_num;",
		"        if (need_dfs_stack) dfs_stack.push_back(u);",
		"        for (auto [v, w]: adj[u]) {",
		"            if (v == p && is_undirected) continue; // ensures that cycle of length 2 are not counted for undirected graphs",
		"            if (vis[v] == 1) {",
		"                contains_cycle = 1; // Cycle detected (for both directed and undirected graph)",
		"            }",
		"            if (!vis[v]) _dfs(v, u, comp_num);",
		"        }",
		"        if (need_dfs_stack) dfs_stack.pop_back();",
		"        vis[u] = 2;",
		"        if (doing_dfs_finishorder) finish_order.push_back(u);",
		"    }",
		"    void _dfsx2(int u, int col) { // particularly for dfs_coloring()",
		"        component[u] = col;",
		"        for (auto [v, w]: adj[u]) {",
		"            if (component[v] == 0) _dfsx2(v, col);",
		"        }",
		"    }",
		"    void _dfsx3(int u, int col) { // particularly for bipartite_check()",
		"        bi_color[u] = col;",
		"        for (auto [v, w]: adj[u]) {",
		"            if (bi_color[v] == bi_color[u]) is_bipartite = 0;",
		"            if (bi_color[v] == 0) _dfsx3(v, 1 ^ 2 ^ col);",
		"        }",
		"    } ",
		"    void dfs(int start, bool reset_vis = 0, int mark_component = 0, bool dfsstack_flag = 0, bool need_finish_order = 0) {",
		"        assert(start >= 0 && start < n);",
		"        if (vis.empty() || reset_vis) vis.assign(n, 0); // This way, we can use like a normal dfs, calling it multiple times is possible",
		"        if (vis[start]) return;",
		"        need_dfs_stack = dfsstack_flag; // even if you forget to reset vis for first dfs, it will auto reset it the first time",
		"        if (need_dfs_stack) dfs_stack.clear();",
		"        doing_dfs_finishorder = need_finish_order;",
		"        doing_dfs_components = mark_component;",
		"        if (mark_component) if (component.empty() || reset_vis) component.assign(n, 0); // reset_vis also resets components",
		"        _dfs(start, -1, mark_component);",
		"        need_dfs_stack = doing_dfs_finishorder = doing_dfs_components = 0;",
		"    }",
		"    int dfs_components() {",
		"        component.assign(n, 0); // also acts as a visited array for _dfsx2",
		"        int col = 1; // slightly more optimal as it doesn't use separate vis and components array",
		"        for (int i = 0; i < n; i++) if (component[i] == 0) _dfsx2(i, col++); // col++ should be ok as we're not taking by ref.",
		"        return components = col - 1;",
		"    }",
		"    void bipartite_check() { // assuming undirected graph",
		"        assert(is_undirected);",
		"        is_bipartite = 1;",
		"        bi_color.assign(n, 0);",
		"        for (int i = 0; i < n; i++) if (bi_color[i] == 0) _dfsx3(i, 1);",
		"    }",
		"    bool is_connected() { // assuming undirected graph",
		"        assert(is_undirected);",
		"        dfs(0, 1);",
		"        for (int i = 0; i < n; i++) if (!vis[i]) return 0;",
		"        return 1;",
		"    }",
		"    bool has_cycle() { // for both directed and undirected",
		"        contains_cycle = 0;",
		"        dfs(0, 1);",
		"        for (int i = 0; i < n; i++) if (!vis[i]) dfs(i, 0);",
		"        return contains_cycle;",
		"    }",
		"    void djikstra(vector<int> &start) { // Accepts a vector of start nodes",
		"        dist.assign(n, numeric_limits<T>::max()); // if node is unreachable then dist is numeric_limits<T>::max()",
		"        priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> pq;",
		"        for (int x: start) {",
		"            assert(x >= 0 && x < n);",
		"            pq.push({0, x});",
		"        }",
		"        while (!pq.empty()) {",
		"            auto [cost, u] = pq.top();",
		"            pq.pop();",
		"            if (cost >= dist[u]) continue;",
		"            dist[u] = cost;",
		"            for (auto [v, w]: adj[u]) {",
		"                if (cost + w < dist[v]) pq.push({cost + w, v});",
		"            }",
		"        }",
		"    }",
		"    bool is_dag(bool allow_ind_change = 0) { // Must set calc_ind flag to 1 for the constructor",
		"        assert(!is_undirected);",
		"        if (allow_ind_change) {",
		"            assert(indegree.size() == n); // Ensures the above",
		"            topo_order.clear(); // Warning: is_dag resets all indegrees if it doesn't make a copy",
		"            queue<int> ready;",
		"            for (int i = 0; i < n; i++) if (indegree[i] == 0) ready.push(i);",
		"            int cnt = 0;",
		"            while (!ready.empty()) {",
		"                cnt++;",
		"                int u = ready.front();",
		"                ready.pop();",
		"                topo_order.push_back(u);",
		"                for (auto [v, w]: adj[u]) {",
		"                    indegree[v]--;",
		"                    if (indegree[v] == 0) ready.push(v);",
		"                }",
		"            }",
		"            return (cnt == n);",
		"        }",
		"        else {",
		"            vector<int> ind_copy = indegree;",
		"            assert(ind_copy.size() == n); // Ensures the above",
		"            topo_order.clear(); ",
		"            queue<int> ready;",
		"            for (int i = 0; i < n; i++) if (ind_copy[i] == 0) ready.push(i);",
		"            int cnt = 0;",
		"            while (!ready.empty()) {",
		"                cnt++;",
		"                int u = ready.front();",
		"                ready.pop();",
		"                topo_order.push_back(u);",
		"                for (auto [v, w]: adj[u]) {",
		"                    ind_copy[v]--;",
		"                    if (ind_copy[v] == 0) ready.push(v);",
		"                }",
		"            }",
		"            return (cnt == n);",
		"        }",
		"    }",
		"    bool eulerian(bool allow_edge_removal = 0) { // Eulerian path/cycle for undirected graph",
		"        assert(is_undirected);",
		"        if constexpr (is_same<T2, set<pair<int, T>>>::value) {",
		"            assert(indegree.size() == n); // calc_ind flag must be set to 1 for constructor",
		"            function<void(int)> _dfs_eu = [&](int u) {",
		"                vis[u] = 1;",
		"                for (auto [v, w]: adj[u]) if (!vis[v]) _dfs_eu(v);",
		"            };",
		"            vis.assign(n, 0); // Warning: eulerian() may remove all or some edges from the graph.",
		"            _dfs_eu(0);",
		"            int start = 0;",
		"            int cnt_odd = 0;",
		"            for (int i = 0; i < n; i++) {",
		"                if (!vis[i]) {",
		"                    vis.clear();",
		"                    return 0; // not connected",
		"                }",
		"                if (indegree[i] % 2) {",
		"                    cnt_odd++;",
		"                    start = i;",
		"                }",
		"            }",
		"            vis.clear();",
		"            if (cnt_odd != 0 && cnt_odd != 2) return 0; // not an eulerian graph",
		"            stack<int> stck;",
		"            stck.push(start);",
		"            eulerian_path.clear();",
		"            if (allow_edge_removal) {",
		"                while (!stck.empty()) {",
		"                    int u = stck.top();",
		"                    if (adj[u].empty()) {",
		"                        stck.pop();",
		"                        eulerian_path.push_back(u);",
		"                    }",
		"                    else {",
		"                        auto [v, w] = *adj[u].begin();",
		"                        adj[u].erase({v, w});",
		"                        adj[v].erase({u, w});",
		"                        m--;",
		"                        stck.push(v);",
		"                    }",
		"                }",
		"            } else {",
		"                vector<set<pair<int, T>>> adj_copy = adj;",
		"                while (!stck.empty()) {",
		"                    int u = stck.top();",
		"                    if (adj_copy[u].empty()) {",
		"                        stck.pop();",
		"                        eulerian_path.push_back(u);",
		"                    }",
		"                    else {",
		"                        auto [v, w] = *adj_copy[u].begin();",
		"                        adj_copy[u].erase({v, w});",
		"                        adj_copy[v].erase({u, w});",
		"                        stck.push(v);",
		"                    }",
		"                }",
		"            }",
		"            return 1;",
		"        }",
		"        else {",
		"            cerr << \"Erorr. eulerian() requires adj set, not adj list.\\n\";",
		"            exit(1);",
		"        }",
		"    }",
		"    bool eulerian_dir(bool allow_edge_removal = 0) { // eulerian check for directed graph",
		"        assert(!is_undirected);",
		"        if constexpr (is_same<T2, set<pair<int, T>>>::value) {",
		"            assert(indegree.size() == n && outdegree.size() == n); // calc_ind & calc_outd flag must be set to 1 for constructor",
		"            if (kosaraju() != 1) {",
		"                return 0; // Not strongly connected",
		"            } ",
		"            int start = 0;",
		"            int cnt_out = 0;",
		"            int cnt_in = 0;",
		"            for (int i = 0; i < n; i++) {",
		"                if (indegree[i] == outdegree[i]) continue;",
		"                if (abs(indegree[i] - outdegree[i]) > 1) {",
		"                    cnt_out = 10; break;",
		"                }",
		"                if (outdegree[i] - indegree[i] == 1) {",
		"                    cnt_out++;",
		"                    start = i;",
		"                }",
		"                else {",
		"                    cnt_in++;",
		"                }",
		"            }",
		"            if (!((cnt_out == 0 && cnt_in == 0) || (cnt_out == 1 && cnt_in == 1))) {",
		"                return 0; // Not an eulerian graph",
		"            }",
		"            stack<int> stck;",
		"            stck.push(start);",
		"            eulerian_path.clear();",
		"            if (allow_edge_removal) {",
		"                while (!stck.empty()) {",
		"                    int u = stck.top();",
		"                    if (adj[u].empty()) {",
		"                        stck.pop();",
		"                        eulerian_path.push_back(u);",
		"                    }",
		"                    else {",
		"                        auto [v, w] = *adj[u].begin();",
		"                        adj[u].erase({v, w});",
		"                        m--;",
		"                        stck.push(v);",
		"                    }",
		"                }",
		"            } else {",
		"                vector<set<pair<int, T>>> adj_copy = adj;",
		"                while (!stck.empty()) {",
		"                    int u = stck.top();",
		"                    if (adj_copy[u].empty()) {",
		"                        stck.pop();",
		"                        eulerian_path.push_back(u);",
		"                    }",
		"                    else {",
		"                        auto [v, w] = *adj_copy[u].begin();",
		"                        adj_copy[u].erase({v, w});",
		"                        stck.push(v);",
		"                    }",
		"                }",
		"            }",
		"            reverse(eulerian_path.begin(), eulerian_path.end());",
		"            return 1;",
		"        }",
		"        else {",
		"            cerr << \"Erorr. eulerian_dir() requires adj set, not adj list.\\n\";",
		"            exit(1);",
		"        }",
		"    }",
		"    int kosaraju() {",
		"        assert(!is_undirected);",
		"        assert(need_rev_edges); // flag must be set in constructor",
		"        finish_order.clear();   ",
		"        dfs(0, 1, 0, 0, 1);",
		"        for (int i = 0; i < n; i++) if (!vis[i]) dfs(i, 0, 0, 0, 1);",
		"        vis.clear();",
		"        assert(finish_order.size() == n);",
		"        component.assign(n, 0);",
		"        function<void(int, int)> _dfsx4 = [&](int u, int col) {",
		"            component[u] = col;",
		"            for (auto [v, w]: radj[u]) if (component[v] == 0) _dfsx4(v, col);",
		"        };",
		"        int colr = 1; ",
		"        for (int i = n - 1; i >= 0; i--) {",
		"            int u = finish_order[i];",
		"            if (component[u] == 0) _dfsx4(u, colr++);",
		"        }",
		"        return components = colr - 1;",
		"    }",
		"};"
	],
	"description": "Graph"
	},
	"prefix2d": {
	"prefix": "prefix2d",
	"body": [
		"template <typename T>",
		"class prefix2d {",
		"    int n, m;",
		"    vector<vector<T>> pre;",
		"    prefix2d(vector<vector<T>> &a) { // 0-indexed array",
		"        n = a.size();",
		"        assert(n > 0);",
		"        m = a[0].size();",
		"        assert(m > 0);",
		"        pre.assign(n + 1, vector<T>(m + 1, 0));",
		"        for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) ",
		"            pre[i][j] = a[i - 1][j - 1] + pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1];",
		"    }",
		"    T query(int r1, int c1, int r2, int c2) { // top left (r1, c1) and bottom right (r2, c2)",
		"        return pre[r2][c2] - pre[r2][c1 - 1] - pre[r1 - 1][c2] + pre[r1 - 1][c1 - 1];",
		"    }",
		"};"
	],
	"description": "prefix2d"
	},
	"dsu": {
	"prefix": "dsu",
	"body": [
		"class dsu {",
		"    int n;",
		"    vector<int> par, siz;",
		"public:",
		"    dsu(int x) { // assuming 0-indexed",
		"        n = x;",
		"        assert(n > 0);",
		"        par.resize(n);",
		"        iota(par.begin(), par.end(), 0);",
		"        siz.assign(n, 1);",
		"    }",
		"    int find(int u) {",
		"        assert(u >= 0 && u < n);",
		"        if (u == par[u]) return u;",
		"        return par[u] = find(par[u]);",
		"    }",
		"    bool unite(int u, int v) {",
		"        assert(u >= 0 && u < n && v >= 0 && v < n);",
		"        if ((u = find(u)) == (v = find(v))) return 0;",
		"        if (siz[u] < siz[v]) {",
		"            par[u] = v;",
		"            siz[v] += siz[u];",
		"        }",
		"        else {",
		"            par[v] = u;",
		"            siz[u] += siz[v];",
		"        }",
		"        return 1;",
		"    }",
		"};"
	],
	"description": "dsu"
	},
	  "loop": {
		"prefix": "loop",
		"body": [
		  "for (int i = 0; i < n$0; i++) {",
		  "    ",
		  "}"
		],
		"description": "for loop"
	  },
	  "loopj": {
		"prefix": "loopj",
		"body": [
		  "for (int j = 0; j < n$0; j++) {",
		  "    ",
		  "}"
		],
		"description": "for loop"
	  },
	  "loopk": {
		"prefix": "loopk",
		"body": [
		  "for (int k = 0; k < n$0; k++) {",
		  "    ",
		  "}"
		],
		"description": "for loop"
	  },
	  "loopk2": {
		"prefix": "loopk2",
		"body": [
		  "for (int k2 = 0; k2 < n$0; k2++) {",
		  "    ",
		  "}"
		],
		"description": "for loop"
	  },
	  "loopk3": {
		"prefix": "loopk3",
		"body": [
		  "for (int k3 = 0; k3 < n$0; k3++) {",
		  "    ",
		  "}"
		],
		"description": "for loop"
	  },
	  "sort ascending": {
		"prefix": "sa",
		"body": [
		  "sort($0a.begin(), a.end());"
		],
		"description": "sort ascending"
	  },
	  "sort descending": {
		"prefix": "sd",
		"body": [
		  "sort($0a.begin(), a.end(), greater<int>());"
		],
		"description": "sort descending"
	  },
	  "lower bound": {
		"prefix": "lower bound",
		"body": [
		  "lower_bound($0a.begin(), a.end(), ) - a.begin();"
		],
		"description": "lower bound"
	  },
	  "upper bound": {
		"prefix": "upper bound",
		"body": [
		  "upper_bound($0a.begin(), a.end(), ) - a.begin();"
		],
		"description": "upper bound"
	  },
	  "vector<vector<int>>": {
		"prefix": "vcc",
		"body": [
		  "vector<vector<int>> $0"
		],
		"description": "vector<vector<int>>"
	  },
	  "size()": {
		"prefix": "sz",
		"body": [
		  "size();"
		],
		"description": "size()"
	  },
	  "return 0": {
		"prefix": "rt",
		"body": [
		  "return;$0"
		],
		"description": "return 0"
	  },
	  "temporary variable": {
		"prefix": "tmp",
		"body": [
		  "$0int tmp;",
		],
		"description": "temporary variable"
	  },
	  "custom comparator function": {
		"prefix": "comp",
		"body": [
		  "bool comp(const int &a, const int &b) {",
		  "// Good to go with sort (begin(), end(), comp)",
		  "    if ($0a > b) {",
		  "        return true;",
		  "    }",
		  "    return false;",
		  "}"
		],
		"description": "custom comparator function"
	  },
	  "custom comparision functor": {
		"prefix": "comps",
		"body": [
		  "typedef struct comp {",
		  "// Good to go with set (int, comp), priority queue (int, vector<int>, comp) or sort (begin(), end(), comp())",
		  "// Also with map<int, int, comp>",
		  "    bool operator() (const int &a, const int &b) const {",
		  "        if ($0a > b) {",
		  "            return true;",
		  "        }",
		  "        return false;",
		  "    } ",
		  "} comp;"
		],
		"description": "custom comparision functor"
	  },
	  "testcase": {
		"prefix": "testcase",
		"body": [
		  "int tests;",
		  "cin >> tests; ",
		  "for (int test = 0; test < tests; test++) {",
		  "    $0",
		  "}",
		],
		"description": ""
	  },
	  "kl": {
		"prefix": "kl",
		"body": [
		  "\"\\n\"$0",
		],
		"description": ""
	  },
	  "vc": {
		"prefix": "vc",
		"body": [
		  "vector<int>$0"
		],
		"description": "vector<int>"
	  },
	  "while loop": {
		"prefix": "while",
		"body": [
		  "while ($0) {",
		  "    ",
		  "}"
		],
		"description": "while loop"
	  },
	  "reverse loop": {
		"prefix": "rloop",
		"body": [
		  "for (int i = n$0 - 1; i >= 0; i--) {",
		  "    ",
		  "}    "
		],
		"description": "reverse loop"
	  },
	  "reverse loop j": {
		"prefix": "rloj",
		"body": [
		  "for (int j = n$0 - 1; j >= 0; j--) {",
		  "    ",
		  "}    "
		],
		"description": "reverse loop j"
	  },
	  "reverse loop k": {
		"prefix": "rlok",
		"body": [
		  "for (int k = n$0 - 1; k >= 0; k--) {",
		  "    ",
		  "}    "
		],
		"description": "reverse loop k"
	  },
	  "square root": {
		"prefix": "sqroot",
		"body": [
		  "ll sq_root(ll x) {",
		  "    if (x < 0) {",
		  "        cout << \"Error: Imaginary no.\";",
		  "        return 0;",
		  "    }",
		  "    ll lo = 0, hi = 3e9;",
		  "    ll ans = 0;",
		  "    while (lo <= hi) {",
		  "        ll mid = (lo + hi) / 2;",
		  "        if (mid * mid <= x) {",
		  "            ans = mid;",
		  "            lo = mid + 1;",
		  "        } else {",
		  "            hi = mid - 1;",
		  "        }",
		  "    }",
		  "    return ans;",
		  "}"
		],
		"description": "square root"
	  },
	  "my gcd function": {
		"prefix": "gcd_me",
		"body": [
		  "ll gcd_me(ll a, ll b) {",
		  "    // O(log(min(a, b)))",
		  "    // Note that gcd is defined even for 0 as well as negative numbers",
		  "    // This code is indeed correct for all pairs of integers",
		  "    a = (a < 0) ? -a : a;",
		  "    b = (b < 0) ? -b : b;",
		  "    if (b == 0) {",
		  "        return a;",
		  "    }",
		  "    return gcd_me(b, a % b);",
		  "}"
		],
		"description": "my gcd function"
	  },
	  "rolling hash": {
		"prefix": "rolling_hash",
		"body": [
		  "int bin_exp(int a, int b)",
		  "{",
		  "    // can handle b = 0",
		  "    int prod = a, ans = 1;",
		  "    while (b != 0)",
		  "    {",
		  "        if (b % 2 == 1)",
		  "        {",
		  "            ans = (1LL * ans * prod) % mod;",
		  "        }",
		  "        prod = (1LL * prod * prod) % mod;",
		  "        b /= 2;",
		  "    }",
		  "    return ans;",
		  "}",
		  "",
		  "void rolling_hasher(string &s, int p, vector<int> &pre, vector<int> &suf) {",
		  "    // Usage: give it pre and suf of size n, prime number p > 122 = 'z'. ",
		  "    // Candidates for p: 179, 191, 193, 197, 199. The more hashes you create, the lesser the chances of collision ",
		  "    // No global variables needed for this implementation except const int mod",
		  "    int n = s.size();",
		  "    if (pre.size() != n || suf.size() != n) {",
		  "        cout << \"Error: pre and suf size should be equal to s.size()\\n\";",
		  "        return;",
		  "    }",
		  "    pre[0] = s[0];",
		  "    for (int i = 1; i < n; i++) {",
		  "        pre[i] = (0LL + ((1LL * pre[i - 1] * p) % mod) + s[i]) % mod;",
		  "    }",
		  "    suf[n - 1] = s[n - 1];",
		  "    for (int i = n - 2; i >= 0; i--) {",
		  "        suf[i] = (0LL + ((1LL * suf[i + 1] * p) % mod) + s[i]) % mod;",
		  "    }",
		  "}",
		  "",
		  "bool rolling_checker(string &s, int p, vector<int> &pre, vector<int> &suf, int l, int r) {",
		  "    // 0 indexed, tells whether the substring is a pallindrome or not",
		  "    int n = s.size();",
		  "    if (l == r) {",
		  "        return true;",
		  "    }",
		  "    int mid = (l + r) / 2;",
		  "    int mid2 = mid + 1;",
		  "    if ((r - l + 1) % 2 == 1) {",
		  "        mid--;",
		  "    }",
		  "    int sum1 = (0LL + pre[mid] - ((l > 0) ? ((1LL * pre[l - 1] * bin_exp(p, mid - l + 1)) % mod) : 0)) % mod;",
		  "    int sum2 = (0LL + suf[mid2] - ((r < n - 1) ? ((1LL * suf[r + 1] * bin_exp(p, r - mid2 + 1)) % mod) : 0)) % mod;",
		  "    sum1 = (0LL + sum1 + mod) % mod;",
		  "    sum2 = (0LL + sum2 + mod) % mod;",
		  "    return (sum1 == sum2);",
		  "}"
		],
		"description": "rolling hash"
	  },
	  "find all cycles": {
		"prefix": "cycles",
		"body": [
		  "// Complexity of code is O(n + m) for dfs, but iterating over every cycle can be O(n^2)",
		  "// dfs on directed, weighted graph to find cycles (will also work for undirected) (weight does not make a difference).",
		  "// need predefined global variables: vector<vector<ii>> edges: (neighbor-cost), vector<int> col (node color), par (node parent)",
		  "// col[u] = 0: unvisited, 1: active, 2: processed (such nodes can only be visited again in a directed graph)",
		  "// par[u] = -1: no parent, otherwise parent of u",
		  "// u: current node, p: parent node",
		  "// Loop on all nodes. Run this function on node u if col[u] == 0. ",
		  "// Finds all simple cycles in the graph. If cycle is found, can be printed using par[], but this may be O(n^2).",
		  "void find_cycles(int u, int p) {",
		  "    col[u] = 1;",
		  "    for (auto [v, w] : edges[u]) {",
		  "        if (v == p) {",
		  "            continue;",
		  "        }",
		  "        if (col[v] == 2) {",
		  "            continue;",
		  "        }",
		  "        if (col[v] == 0) {",
		  "            par[v] = u;",
		  "            find_cycles(v, u);",
		  "        }",
		  "        if (col[v] == 1) {",
		  "            // Cycle detected",
		  "        }",
		  "    }",
		  "    col[u] = 2;",
		  "}"
		],
		"description": "find all cycles"
	  },
	  "generalized segment tree": {
		"prefix": "segtree",
		"body": [
		  "typedef struct Node {",
		  "    int val, left, right;",
		  "} Node;",
		  "",
		  "int st_def = 0, tree_type = 0;",
		  "vector<Node> segtree;",
		  "vector<int> lazy;",
		  "",
		  "// Function Declaration",
		  "",
		  "void set_tree_type(int type) {",
		  "    /* Usage: First call set_tree_type function to set tree type. ",
		  "        Next, use segtree.assign(4*n, {st_def, -1, -1}); lazy.assign(4*n, 0)",
		  "        Next, give your array to build(n, arr) to construct segment tree",
		  "        Now you can update or query any range you want",
		  "        Note that update adds k to all elements in range [l, r] ",
		  "        Always call query and update at x = 1 to start at the top of tree for the entire range [0, n)",
		  "        Note that l, r given to the functions query and update are 0 indexed ",
		  "        Build is O(4n). Query and Update are O(logn) */",
		  "    if (type == 0) { // sum",
		  "        st_def = 0;",
		  "        tree_type = 0;",
		  "    } else if (type == 1) {",
		  "        st_def = 2e9; // min",
		  "        tree_type = 1;",
		  "    } else if (type == 2) {",
		  "        st_def = -2e9; // max",
		  "        tree_type = 2;",
		  "    }",
		  "}",
		  "",
		  "int mul_val(int type, int x) {",
		  "    int ans = 1;",
		  "    if (type == 0) {",
		  "        ans = segtree[x].right - segtree[x].left + 1;",
		  "    }",
		  "    return ans;",
		  "}",
		  "",
		  "int ret_val(int type, int v1, int v2) {",
		  "    int ans;",
		  "    if (type == 0) {",
		  "        ans = v1 + v2;",
		  "    } else if (type == 1) {",
		  "        ans = min(v1, v2);",
		  "    } else if (type == 2) {",
		  "        ans = max(v1, v2);",
		  "    }",
		  "    return ans;",
		  "}",
		  "",
		  "// build seg tree O(4n)",
		  "void build(const int n, const vector<int> &a) {",
		  "    int h = ceil(log2(n));",
		  "    int t = 1 << h;",
		  "    for (int i = 0; i < n; i++) {",
		  "        segtree[t + i] = {a[i], i, i};",
		  "    }",
		  "    for (int i = h - 1; i >= 0; i--) {",
		  "        t = 1 << i; // number of nodes on current level, also the index of first node on current level",
		  "        for (int j = 0; j < t; j++) {",
		  "            segtree[t + j].val = ret_val(tree_type, segtree[2 * (t + j)].val, segtree[2 * (t + j) + 1].val);",
		  "            if (segtree[2 * (t + j)].left != -1) {",
		  "                segtree[t + j].left = segtree[2 * (t + j)].left;",
		  "            } else {",
		  "                segtree[t + j].left = segtree[2 * (t + j) + 1].left;",
		  "            }",
		  "            if (segtree[2 * (t + j) + 1].right != -1) {",
		  "                segtree[t + j].right = segtree[2 * (t + j) + 1].right;",
		  "            } else {",
		  "                segtree[t + j].right = segtree[2 * (t + j)].right;",
		  "            }",
		  "        }   ",
		  "    }",
		  "}",
		  "",
		  "// query in range [l, r] O(logn)",
		  "int query(int n, int x, int l, int r) {",
		  "    auto& [val, left, right] = segtree[x];",
		  "    if (l > right || r < left) {",
		  "        return st_def;",
		  "    }",
		  "    if (l <= left && right <= r) {",
		  "        return val;",
		  "    }",
		  "    if (lazy[x] != 0) {",
		  "        int h = ceil(log2(n));",
		  "        int t = 1 << h;",
		  "        if (x < t) {",
		  "            segtree[2 * x].val += lazy[x] * (segtree[2 * x].right - segtree[2 * x].left + 1);",
		  "            segtree[2 * x + 1].val += lazy[x] * (segtree[2 * x + 1].right - segtree[2 * x + 1].left + 1);",
		  "            lazy[2 * x] += lazy[x];",
		  "            lazy[2 * x + 1] += lazy[x];",
		  "        }",
		  "        lazy[x] = 0;",
		  "    }",
		  "    // It is not possible to reach here if x is a leaf node",
		  "    return ret_val(tree_type, query(n, 2 * x, l, r), query(n, 2 * x + 1, l, r));",
		  "}",
		  "",
		  "// lazy[x] = z means that the value of x is updated but all of its children have to be increased by z later",
		  "void range_update(int n, int x, int l, int r, int k) {",
		  "    auto& [val, left, right] = segtree[x];",
		  "    if (l > right || r < left) {",
		  "        return;",
		  "    }",
		  "    if (l <= left && right <= r) {",
		  "        val += k * mul_val(tree_type, x);",
		  "        lazy[x] += k;",
		  "        return;",
		  "    }",
		  "    if (lazy[x] != 0) {",
		  "        int h = ceil(log2(n));",
		  "        int t = 1 << h;",
		  "        if (x < t) {",
		  "            segtree[2 * x].val += lazy[x] * mul_val(tree_type, 2 * x);",
		  "            segtree[2 * x + 1].val += lazy[x] * mul_val(tree_type, 2 * x + 1);",
		  "            lazy[2 * x] += lazy[x];",
		  "            lazy[2 * x + 1] += lazy[x];",
		  "        }",
		  "        lazy[x] = 0;",
		  "    }",
		  "    // It is not possible to reach here if x is a leaf node",
		  "    range_update(n, 2 * x, l, r, k);",
		  "    range_update(n, 2 * x + 1, l, r, k);",
		  "    val = ret_val(tree_type, segtree[2 * x].val, segtree[2 * x + 1].val);",
		  "}"
		],
		"description": "generalized segment tree"
	  },
	"fenwick tree": {
	"prefix": "fenwick tree",
	"body": [
		"template <typename T = long long>",
		"class fenwick_tree {",
		"    int n;",
		"    vector<T> fenwick;",
		"public:",
		"    fenwick_tree(vector<T> &a) { // assuming a is 0-indexed",
		"        assert(a.size() > 0);",
		"        n = a.size();",
		"        fenwick.assign(n + 1, 0);",
		"        for (int i = 0; i < n; i++) increase(i, a[i]);",
		"    }",
		"    void increase(int i, T val) { // assuming i is 0-indexed",
		"        assert(i >= 0 && i < n);",
		"        i++;",
		"        while (i <= n) {",
		"            fenwick[i] += val;",
		"            i += (i & (-i));",
		"        }",
		"    }",
		"    T prefix_sum(int i) { // assuming i is 0-indexed",
		"        assert(i >= 0 && i < n);",
		"        i++;",
		"        T sum = 0;",
		"        while (i >= 1) {",
		"            sum += fenwick[i];",
		"            i -= (i & (-i));",
		"        }",
		"        return sum;",
		"    }",
		"};"
	],
	"description": "fenwick tree"
	},
	"read array": {
	"prefix": "read array",
	"body": [
		"for (int i = 0, _n = $0a.size(); i < _n; i++) {",
		"    cin >> a[i];",
		"}"
	],
	"description": "read array"
	},
	"sparse table max": {
	"prefix": "sparse table max",
	"body": [
		"template <typename T = long long>",
		"class sparse_table_max {",
		"    int n, k;",
		"    vector<vector<T>> sp;",
		"public:",
		"    sparse_table_max(vector<T> &a) { // assuming a is 0-indexed",
		"        n = a.size();",
		"        assert(n > 0);",
		"        k = 32 - __builtin_clz(n); // k = __lg(n) + 1 = log2(n) + 1 = 32 - __builtin_clz(n) - 1 + 1",
		"        sp.assign(n, vector<T> (k, -1));",
		"        for (int i = n - 1; i >= 0; i--) {",
		"            sp[i][0] = a[i];",
		"            for (int j = 1; i + (1 << j) - 1 < n; j++) {",
		"                sp[i][j] = max(sp[i][j - 1], sp[i + (1 << (j - 1))][j - 1]);",
		"            }",
		"        }",
		"    }",
		"    T query(int l, int r) { // assuming l, r are 0-indexed",
		"        assert(l >= 0 && l < n && r >= 0 && r < n && l <= r);",
		"        int tmp = 32 - __builtin_clz(r - l + 1) - 1;",
		"        return max(sp[l][tmp], sp[r - (1 << tmp) + 1][tmp]);",
		"    }",
		"};"
	],
	"description": "sparse table max"
	},
	"sparse table min": {
	"prefix": "sparse table min",
	"body": [
		"template <typename T = long long>",
		"class sparse_table_min {",
		"    int n, k;",
		"    vector<vector<T>> sp;",
		"public:",
		"    sparse_table_min(vector<T> &a) { // assuming a is 0-indexed",
		"        n = a.size();",
		"        assert(n > 0);",
		"        k = 32 - __builtin_clz(n); // k = __lg(n) + 1 = log2(n) + 1 = 32 - __builtin_clz(n) - 1 + 1",
		"        sp.assign(n, vector<T> (k, -1));",
		"        for (int i = n - 1; i >= 0; i--) {",
		"            sp[i][0] = a[i];",
		"            for (int j = 1; i + (1 << j) - 1 < n; j++) {",
		"                sp[i][j] = min(sp[i][j - 1], sp[i + (1 << (j - 1))][j - 1]);",
		"            }",
		"        }",
		"    }",
		"    T query(int l, int r) { // assuming l, r are 0-indexed",
		"        assert(l >= 0 && l < n && r >= 0 && r < n && l <= r);",
		"        int tmp = 32 - __builtin_clz(r - l + 1) - 1;",
		"        return min(sp[l][tmp], sp[r - (1 << tmp) + 1][tmp]);",
		"    }",
		"};"
	],
	"description": "sparse table min"
	},
	"sparse table gcd": {
	"prefix": "sparse table gcd",
	"body": [
		"template <typename T = long long>",
		"class sparse_table_gcd {",
		"    int n, k;",
		"    vector<vector<T>> sp;",
		"public:",
		"    sparse_table_gcd(vector<T> &a) { // assuming a is 0-indexed",
		"        n = a.size();",
		"        assert(n > 0);",
		"        k = 32 - __builtin_clz(n); // k = __lg(n) + 1 = log2(n) + 1 = 32 - __builtin_clz(n) - 1 + 1",
		"        sp.assign(n, vector<T> (k, -1));",
		"        for (int i = n - 1; i >= 0; i--) {",
		"            assert(a[i] > 0);",
		"            sp[i][0] = a[i];",
		"            for (int j = 1; i + (1 << j) - 1 < n; j++) {",
		"                sp[i][j] = __gcd(sp[i][j - 1], sp[i + (1 << (j - 1))][j - 1]); ",
		"            }",
		"        }",
		"    }",
		"    T query(int l, int r) { // assuming l, r are 0-indexed",
		"        assert(l >= 0 && l < n && r >= 0 && r < n && l <= r);",
		"        int tmp = 32 - __builtin_clz(r - l + 1) - 1;",
		"        return __gcd(sp[l][tmp], sp[r - (1 << tmp) + 1][tmp]);",
		"    }",
		"};"
	],
	"description": "sparse table gcd"
	},
	  "<< debug": {
		"prefix": "d",
		"body": [
		  "<< $0"
		],
		"description": "<< debug"
	  },
	"Hash (Custom)": {
		"prefix": "hash",
		"body": [
			"struct custom_hash { // custom hash function for unordered_map and unordered_set", 
			"    static uint64_t splitmix64(uint64_t x) {",
			"    // Usage: unordered_map<long long, int, custom_hash> safe_map;",
			"    // Usage: unordered_set<long long, custom_hash> safe_set;",
			"        x += 0x9e3779b97f4a7c15;",
			"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"        return x ^ (x >> 31);",
			"    }",
			"    size_t operator()(uint64_t x) const {",
			"        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
			"        return splitmix64(x + FIXED_RANDOM);",
			"    }",
			"};"
		],
		"description": "Hash (Custom)"
		},
	  "cout YES": {
		"prefix": "yy",
		"body": [
		  "cout << \"YES\\n\";$0"
		],
		"description": "cout YES"
	  },
	  "iff": {
		"prefix": "if",
		"body": [
		  "if ($0) {",
		  "    ",
		  "}"
		],
		"description": "if"
	  },
	  "else": {
		"prefix": "el",
		"body": [
		  "else {",
		  "    $0",
		  "}"
		],
		"description": "else"
	  },
	  "break": {
		"prefix": "br",
		"body": [
		  "break;$0"
		],
		"description": "break"
	  },
	  "cout NO": {
		"prefix": "nn",
		"body": [
		  "cout << \"NO\\n\";$0"
		],
		"description": "cout NO"
	  },
	  "ckl": {
		"prefix": "ckl",
		"body": [
		  "cout << \"\\n\";",
		  "$0"
		],
		"description": "cout \n"
	  },
	  "fast io": {
		"prefix": "fast io",
		"body": [
		  "ios_base::sync_with_stdio(0); cin.tie(0);",
		  "$0"
		],
		"description": "fast io"
	  },
	  "cc": {
		"prefix": "cc",
		"body": [
		  "cout << \"$0\";"
		],
		"description": "cout"
	  },
	  "cn": {
		"prefix": "cn",
		"body": [
		  "cin >> $0;"
		],
		"description": "cin"
	  },
	"modular exponentiation": {
	"prefix": "bem",
	"body": [
		"int be(int a, int b) {",
		"    int ans = 1;",
		"    while (b > 0) {",
		"        if (b & 1) ans = (1ll * ans * a) % mod;",
		"        a = (1ll * a * a) % mod;",
		"        b >>= 1;",
		"    }",
		"    return ans;",
		"}"
	],
	"description": "modular exponentiation"
	},
	"binary exponentiation": {
	"prefix": "be",
	"body": [
		"int be(int a, int b) {",
		"    int ans = 1;",
		"    while (b > 0) {",
		"        if (b & 1) ans *= a;",
		"        a *= a;",
		"        b >>= 1;",
		"    }",
		"    return ans;",
		"}"
	],
	"description": "binary exponentiation"
	},
	  "cmod":{
		"prefix": "cmod",
		"body": [
			"const int mod = 1e9 + 7;$0"
		],
		"description": ""
	  },
	  "2dp": {
		"prefix": "2dp",
		"body": [
		  "for (auto aut1 : $0) {",
		  "    for (auto aut2: aut1) {",
		  "        cout << aut2 << \" \"; ",
		  "    }",
		  "    cout << \"\\n\";",
		  "}"
		],
		"description": "print 2D vector"
	  },
	  "1dp": {
		"prefix": "1dp",
		"body": [
		  "for (auto aut : $0) {",
		  "    cout << aut << \" \";",
		  "} ",
		  "cout << \"\\n\";"
		],
		"description": "print 1D vector"
	  },
	  "mask": {
		"prefix": "mask",
		"body": [
		  "for (int j = 0; j < (1 << a.size()); j++)",
		  "{",
		  "    int ans = 0;",
		  "    for (int k = 0; k < a.size(); k++)",
		  "    {",
		  "        if (j >> k)",
		  "        {",
		  "            ans += a[k];",
		  "        }    ",
		  "    }",
		  "    asums.emplace_back(ans);",
		  "}"
		],
		"description": "bit mask"
	  },
	  "cartesian distance": {
		"prefix": "dist",
		"body": [
		  "double dist(double x1, double y1, double x2, double y2) {",
		  "    double ans = (x2 - x1) * (x2 - x1);",
		  "    ans += ((y2 - y1) * (y2 - y1));",
		  "    ans = sqrt(ans);",
		  "    return ans;",
		  "}"
		],
		"description": "cartesian distance"
	  },
	  "binary search (real)": {
		"prefix": "bin_search",
		"body": [
		  "double lo, hi;",
		  "double ans;",
		  "while (lo <= hi) {",
		  "    double mid = (lo + hi) / 2;",
		  "    if ($0) {",
		  "        ",
		  "    }",
		  "    else {",
		  "        ",
		  "    }",
		  "}"
		],
		"description": "binary search (real)"
	  },
	  "fibonacci": {
		"prefix": "fib",
		"body": [
		  "vector<ll> co1(35), co2(35);",
		  "co1[1] = 1, co1[2] = 0, co2[1] = 0, co2[2] = 1; // no need to change this",
		  "for (int i = 3; i < 32; i++) {",
		  "    co1[i] = co1[i - 1] + co1[i - 2];",
		  "    co2[i] = co2[i - 1] + co2[i - 2];",
		  "}",
		  "// a, b, a+b, a+2b, 2a+3b, 3a+5b, ...",
		  "// co1 and co2 are basically storing the coefficients of a and b at each term",
		  "// so f(n) = co1(n) * a + co2(n) * b; here a = f(1), b = f(2)",
		  "vector<ll> fib(35);",
		  "fib[1] = 0, fib[2] = 1; // make changes here (define first two elements as required)",
		  "for (int i = 3; i < 32; i++) {",
		  "    fib[i] = co1[i] * fib[1] + co2[i] * fib[2];",
		  "}"
		],
		"description": "fibonacci"
	  },
	"redirect IO": {
	"prefix": "redirect IO",
	"body": [
		"freopen(\"C:/Users/SANKET/Desktop/input.txt\", \"r\", stdin);   // Redirects cin to read from input.txt",
		"freopen(\"C:/Users/SANKET/Desktop/output.txt\", \"w\", stdout); // Redirects cout to write to output.txt",
		""
	],
	"description": "redirect IO"
	},
	"generate test cases": {
	"prefix": "generate test cases",
	"body": [
		"#include <bits/stdc++.h>",
		"#include <ext/pb_ds/assoc_container.hpp>",
		"#include <ext/pb_ds/tree_policy.hpp>",
		"",
		"using namespace __gnu_pbds;",
		"template <typename T>",
		"using ordered_set = tree<T, null_type, std::less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
		"",
		"using namespace std;",
		"",
		"typedef long long ll;",
		"typedef long double ld;",
		"typedef pair<int, int> ii;",
		"",
		"// Global Variables & Structures",
		"",
		"",
		"",
		"// Functions",
		"",
		"void solve(int test_id) {",
		"    freopen(\"C:/Users/SANKET/Desktop/input.txt\", \"w\", stdout); // Redirects cout to write to output.txt",
		"    srand(time(0));",
		"    random_device rd;",
		"    mt19937 gen(rd());",
		"    ",
		"    uniform_int_distribution<int> gen_n(1, 10); // call generate(gen) to get a random number",
		"    uniform_int_distribution<int> gen_val(1, 10);",
		"    ",
		"    int max_test_cases = 10;",
		"    cout << max_test_cases << \"\\n\";",
		"    ",
		"    for (int test = 1; test <= 10; test++) {",
		"        int n = gen_n(gen);",
		"        cout << n << \"\\n\";",
		"        for (int i = 0; i < n; i++) {",
		"            int num;",
		"            while ((num = gen_val(gen)) > n);",
		"            cout << num << \" \";",
		"        }",
		"        cout << \"\\n\";",
		"    }",
		"}",
		"",
		"int main(void) {",
		"    ios_base::sync_with_stdio(0); cin.tie(0);",
		"    cout << fixed;",
		"",
		"    int tests = 1;",
		"    // cin >> tests; ",
		"    for (int test = 0; test < tests; test++) {",
		"        solve(test);",
		"    }",
		"}",
		""
	],
	"description": "generate test cases"
	},
	"random number generation": {
	"prefix": "random number generation",
	"body": [
		"srand(time(0));",
		"random_device rd;",
		"mt19937 gen(rd());",
		"uniform_int_distribution<int> generate(minimumvalue, maximumvalue); // call generate(gen) to get a random number"
	],
	"description": "random number generation"
	},
		"segment tree check non dec": {
	"prefix": "segment tree check non dec",
	"body": [
		"template <typename T>",
		"class segment_tree_check_non_dec {",
		"private:",
		"    typedef struct node {",
		"        int l, r;",
		"        bool sorted;",
		"    } node;",
		"    int n;",
		"    vector<node> st;",
		"    void build(int i, int l, int r, vector<T> &a) {",
		"        st[i].l = l, st[i].r = r, st[i].sorted = 0;",
		"        if (leaf(i)) {",
		"            st[i].sorted = 1;",
		"        }",
		"        else {",
		"            int mid = (l + r) / 2;",
		"            build(LC(i), l, mid, a);",
		"            build(RC(i), mid + 1, r, a);",
		"            if (st[LC(i)].sorted && st[RC(i)].sorted && a[st[LC(i)].r] <= a[st[RC(i)].l]) {",
		"                st[i].sorted = 1;",
		"            }",
		"        }",
		"    }",
		"    void update(int i, int pos, vector<T> &a) {",
		"        if (leaf(i)) return; ",
		"        st[i].sorted = 0;",
		"        int mid = (st[i].l + st[i].r) / 2;",
		"        if (pos <= mid) {",
		"            update(LC(i), pos, a);",
		"        }",
		"        else {",
		"            update(RC(i), pos, a);",
		"        }",
		"        if (st[LC(i)].sorted && st[RC(i)].sorted && a[st[LC(i)].r] <= a[st[RC(i)].l]) {",
		"            st[i].sorted = 1;",
		"        }",
		"    }",
		"    bool leaf(int i) {",
		"        return (st[i].l == st[i].r);",
		"    }",
		"    int LC(int i) { // left child of node i",
		"        return 2 * i;",
		"    }",
		"    int RC(int i) { // right child of node i",
		"        return 2 * i + 1;",
		"    }",
		"public: // User functions",
		"    segment_tree_check_non_dec(vector<T> &a) {",
		"        n = a.size();",
		"        assert(n > 0);",
		"        st.resize(4 * n + 3);",
		"        build(1, 0, n - 1, a);",
		"    }",
		"    void point_update(int pos, T val, vector<T> &a) { // assuming l, r are 0-indexed",
		"        assert(pos >= 0 && pos < n);",
		"        a[pos] = val;",
		"        update(1, pos, a);",
		"    }",
		"    bool is_non_dec() {",
		"        return st[1].sorted;",
		"    }",
		"};"
	],
	"description": "segment tree check non dec"
	},
	"bipartite graph": {
	"prefix": "bipartite graph",
	"body": [
		"class bipartite_graph {",
		"    const int NIL, INF; // represents unmatched vertex",
		"    vector<vector<int>> G;",
		"    vector<int> match, dist;",
		"    bool matching_generated;",
		"    int n, m;",
		"    bool bfs() {",
		"        int i, u, v, len;",
		"        queue<int> Q;",
		"        for(i = 1; i <= n; i++) {",
		"            if(match[i] == NIL) {",
		"                dist[i] = 0;",
		"                Q.push(i);",
		"            }",
		"            else dist[i] = INF;",
		"        }",
		"        dist[NIL] = INF;",
		"        while(!Q.empty()) {",
		"            u = Q.front(); Q.pop();",
		"            if(u != NIL) {",
		"                len = G[u].size();",
		"                for(i = 0; i < len; i++) {",
		"                    v = G[u][i];",
		"                    if(dist[match[v]] == INF) {",
		"                        dist[match[v]] = dist[u] + 1;",
		"                        Q.push(match[v]);",
		"                    }",
		"                }",
		"            }",
		"        }",
		"        return (dist[NIL] != INF);",
		"    }",
		"    bool dfs(int u) {",
		"        int i, v, len;",
		"        if(u != NIL) {",
		"            len = G[u].size();",
		"            for(i = 0; i < len; i++) {",
		"                v = G[u][i];",
		"                if(dist[match[v]] == dist[u]+1) {",
		"                    if(dfs(match[v])) {",
		"                        match[v] = u;",
		"                        match[u] = v;",
		"                        return true;",
		"                    }",
		"                }",
		"            }",
		"            dist[u] = INF;",
		"            return false;",
		"        }",
		"        return true;",
		"    }",
		"public:",
		"    bipartite_graph(int size_u, int size_v) : NIL(0), INF(1 << 28) {",
		"        n = size_u, m = size_v;",
		"        G.assign(n + m + 1, vector<int> ());",
		"        match.clear();",
		"        dist.clear();",
		"        matching_generated = 0;",
		"    }",
		"    void add_edge(int u, int v) {",
		"        // n: number of nodes on left side, nodes are numbered 1 to n",
		"        // m: number of nodes on right side, nodes are numbered n+1 to n+m",
		"        G[u].push_back(v);",
		"    }",
		"    int hopcroft_karp() {",
		"        int matching = 0;",
		"        match.assign(n + m + 1, 0);",
		"        dist.assign(n + 1, 0);",
		"        while(bfs())",
		"            for(int i = 1; i <= n; i++)",
		"                if(match[i] == NIL && dfs(i))",
		"                    matching++;",
		"        matching_generated = 1;",
		"        return matching;",
		"    }",
		"    vector<int> get_matching() { // for all the n + m vertices, tells their match",
		"        assert(matching_generated); // hopcroft_karp() must be called first",
		"        return match; // match[i] = 0 denotes unmatched vertices. ",
		"    }",
		"    vector<int> min_vertex_cover() {",
		"        // Ensure that the matching has been generated",
		"        assert(matching_generated);",
		"        ",
		"        // Step 1: Create a visited array",
		"        vector<bool> visited(n + 1, false);",
		"        ",
		"        // Step 2: Perform BFS from all unmatched vertices in the left set",
		"        queue<int> Q;",
		"        for (int i = 1; i <= n; i++) {",
		"            if (match[i] == NIL) {",
		"                Q.push(i);",
		"                visited[i] = true; // Mark as visited",
		"            }",
		"        }",
		"        while (!Q.empty()) {",
		"            int u = Q.front(); Q.pop();",
		"            for (int v : G[u]) {",
		"                if (match[v] != NIL && !visited[match[v]]) { // Check if the matched vertex is not visited",
		"                    visited[match[v]] = true; // Mark it as visited",
		"                    Q.push(match[v]); // Explore it in the next BFS level",
		"                }",
		"            }",
		"        }",
		"        // Step 3: Construct the minimum vertex cover",
		"        vector<int> cover;",
		"        for (int i = 1; i <= n; i++) {",
		"            if (!visited[i]) {",
		"                cover.push_back(i); // Unmatched left vertices",
		"            }",
		"            else if (match[i] != NIL) {",
		"                cover.push_back(match[i]);",
		"            }",
		"        }",
		"        return cover; // Return the minimum vertex cover",
		"    }",
		"};"
	],
	"description": "bipartite graph"
	},
	"matrix exponentiation": {
	"prefix": "matrix_exponentiation",
	"body": [
		"vector<vector<int>> mat_exp(vector<vector<int>> &a, ll p) {",
		"    if (p == 1) return a;",
		"    if (p % 2) {",
		"        auto tmp = mat_exp(a, p - 1);",
		"        return mat_mul(a, tmp);",
		"    }",
		"    auto tmp = mat_exp(a, p / 2);",
		"    return mat_mul(tmp, tmp);",
		"}"
	],
	"description": "matrix exponentiation"
	},
	"matrix multiplication": {
	"prefix": "matrix_multiplication",
	"body": [
		"vector<vector<int>> mat_mul(const vector<vector<int>> &a, const vector<vector<int>> &b) {",
		"    int n1 = a.size(), n2 = b.size();",
		"    assert(n1 > 0 && n2 > 0);",
		"    int m1 = a[0].size(), m2 = b[0].size();",
		"    assert(m1 > 0 && m2 > 0);",
		"    assert(m1 == n2);",
		"    vector<vector<int>> ans(n1, vector<int> (m2, 0));",
		"    for (int i = 0, n = ans.size(), m = ans[0].size(); i < n; i++) {",
		"        for (int j = 0; j < m; j++) {",
		"            int sum = 0;",
		"            for (int k = 0; k < m1; k++) {",
		"                sum = (0ll + sum + ((1ll * a[i][k] * b[k][j]) % mod)) % mod;",
		"            }",
		"            ans[i][j] = sum;",
		"        }",
		"    }",
		"    return ans;",
		"}"
	],
	"description": "matrix multiplication"
	},
	  "factorial calculator": {
		"prefix": "factorial",
		"body": [
		  "vector<int> facts; // Needs a facts array and a mod variable",
		  "void calc_facts(int n) { // Calculates all factorials in range [0, n]",
		  "    facts.resize(n + 1);",
		  "    facts[0] = 1;",
		  "    for (int i = 1; i <= n; i++) {",
		  "        facts[i] = (1LL * facts[i - 1] * i) % mod;",
		  "    }",
		  "}"
		],
		"description": "factorial calculator"
	  },
	  "ncr calculator": {
		"prefix": "ncr",
		"body": [
		  "int nCr(int n, int r) { // needs bin_exp function as well as facts array. Also needs mod variable",
		  "    // Ensure that facts array contains all the factorials that may be required. ",
		  "    int num = facts[n];",
		  "    int den = (1LL * facts[r] * facts[n - r]) % mod;",
		  "    int inv = bin_exp(den, mod - 2);",
		  "    return (1LL * num * inv) % mod;",
		  "}"
		],
		"description": "ncr calculator"
	  },
	  "dfs": {
		"prefix": "dfs",
		"body": [
		  "vector<vector<int>> edges; // edges.assign(n, vector<int> {});",
		  "vector<int> col; // col.assign(n, 0);",
		  "vector<int> par; // par.assign(n, -1);",
		  "void dfs(int u, int p) { // can be 0 or 1 indexed",
		  "    col[u] = 1;",
		  "    par[u] = p;",
		  "    for (auto v: edges[u]) {",
		  "        if (v == p) {",
		  "            continue;",
		  "        }",
		  "        if (col[v] == 2) {",
		  "            continue;",
		  "        }",
		  "        if (col[v] == 1) {",
		  "            // Cycle detected: to print the cycle, make use of a parent array",
		  "        }",
		  "        dfs(v, u);",
		  "    }",
		  "    col[u] = 2;",
		  "}"
		],
		"description": "dfs"
	  },
	  "continue": {
		"prefix": "co",
		"body": [
		  "continue;"
		],
		"description": ""
	  },
	"Eulerian Path": {
		"prefix": "eulerian",
		"body": [
			"// Eulerian Path - hierholzher's algorithm for undirected graph",
			"",
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;",
			"",
			"int n, m;",
			"vector<set<int>> edges;",
			"vector<int> vis;",
			"",
			"void dfs(int u) {",
			"    vis[u] = 1;",
			"    for (int v: edges[u]) {",
			"        if (!vis[v]) {",
			"            dfs(v);",
			"        }",
			"    }",
			"}",
			"",
			"int main() {",
			"    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
			"    cin >> n >> m;",
			"    vector<int> d(n, 0);",
			"    int odd = 0;",
			"    for (int i = 0; i < m; i++) {",
			"        int x, y;",
			"        cin >> x >> y;",
			"        x--, y--;",
			"        edges[x].insert(y);",
			"        edges[y].insert(x);",
			"        d[x]++, d[y]++;",
			"        if (d[x] % 2) odd++;",
			"        else odd--;",
			"        if (d[y] % 2) odd++;",
			"        else odd--;",
			"    }",
			"    if (odd != 0 && odd != 2) {",
			"        cout << \"Non-euler graph.\\n\";",
			"        return 0;",
			"    }",
			"    vis.assign(n, 0);",
			"    dfs(0);",
			"    for (int i = 0; i < n; i++) {",
			"        if (!vis[i]) {",
			"            cout << \"Non-connected graph.\\n\";",
			"            return 0;",
			"        }",
			"    }",
			"    stack<int> st;",
			"    st.push(0);",
			"    vector<int> ans;",
			"    while (!st.empty()) {",
			"        int u = st.top();",
			"        if (edges[u].empty()) {",
			"            ans.push_back(u + 1);",
			"            st.pop();",
			"            continue;",
			"        }",
			"        int v = *(edges[u].begin());",
			"        edges[u].erase(v);",
			"        edges[v].erase(u);",
			"        st.push(v);",
			"    }",
			"    for (auto x: ans) cout << x << \" \";",
			"    cout << \"\\n\";",
			"}"
		],
		"description": "Eulerian Path"
	},
	"Binary Lifting": {
	"prefix": "lca",
	"body": [
		"#include <bits/stdc++.h>",
		"",
		"using namespace std;",
		"",
		"int n, k;",
		"vector<vector<int>> edges;",
		"vector<vector<int>> up;",
		"vector<int> dep;",
		"",
		"void dfs(int u, int p, int d) {",
		"    dep[u] = d;",
		"    up[u][0] = p;",
		"    for (int j = 1; (1 << j) <= d; j++) {",
		"        up[u][j] = up[up[u][j - 1]][j - 1];",
		"    }",
		"    for (int v: edges[u]) {",
		"        if (v == p) continue;",
		"        dfs(v, u, d + 1);",
		"    }",
		"}",
		"",
		"int lca(int u, int v) {",
		"    if (dep[u] < dep[v]) swap(u, v);",
		"    int diff = dep[u] - dep[v]; // u should go up by this much",
		"    for (int j = k; j >= 0; j--) {",
		"        if ((diff >> j) & 1) {",
		"            u = up[u][j];",
		"        }",
		"    }",
		"    if (u == v) return u;",
		"    // find first different ancestor, then go 1 up",
		"    for (int j = k; j >= 0; j--) {",
		"        if (up[u][j] == up[v][j]) continue;",
		"        u = up[u][j], v = up[v][j];",
		"    }",
		"    return up[u][0];",
		"}",
		"",
		"int main() {",
		"    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
		"    cin >> n;",
		"    int tmp = n - 1;",
		"    edges.assign(n, vector<int> ());",
		"    while (tmp--) {",
		"        int u, v;",
		"        cin >> u >> v;",
		"        u--, v--;",
		"        edges[u].push_back(v);",
		"        edges[v].push_back(u);",
		"    }",
		"    k = log2(n) + 1;",
		"    up.assign(n, vector<int> (k, -1));",
		"    dep.assign(n, 0);",
		"    dfs(0, -1, 0); // Assumes 1 rooted",
		"    int q;",
		"    cin >> q;",
		"    while (q--) {",
		"        int l, r;",
		"        cin >> l >> r;",
		"        l--, r--;",
		"        cout << (1 + lca(l, r)) << \"\\n\";",
		"    }",
		"}"
	],
	"description": "Binary Lifting"
	},
	"Modular": {
	"prefix": "modular",
	"body": [
		"template <int MOD=998244353>",
		"struct Modular {",
		"  int value;",
		"  static const int MOD_value = MOD;",
		"",
		"  Modular(long long v = 0) { value = v % MOD; if (value < 0) value += MOD;}",
		"  Modular(long long a, long long b) : value(0){ *this += a; *this /= b;}",
		"",
		"  Modular& operator+=(Modular const& b) {value += b.value; if (value >= MOD) value -= MOD; return *this;}",
		"  Modular& operator-=(Modular const& b) {value -= b.value; if (value < 0) value += MOD;return *this;}",
		"  Modular& operator*=(Modular const& b) {value = (long long)value * b.value % MOD;return *this;}",
		"",
		"  friend Modular mexp(Modular a, long long e) {",
		"    Modular res = 1; while (e) { if (e&1) res *= a; a *= a; e >>= 1; }",
		"    return res;",
		"  }",
		"  friend Modular inverse(Modular a) { return mexp(a, MOD - 2); }",
		"",
		"  Modular& operator/=(Modular const& b) { return *this *= inverse(b); }",
		"  friend Modular operator+(Modular a, Modular const b) { return a += b; }",
		"  friend Modular operator-(Modular a, Modular const b) { return a -= b; }",
		"  friend Modular operator-(Modular const a) { return 0 - a; }",
		"  friend Modular operator*(Modular a, Modular const b) { return a *= b; }",
		"  friend Modular operator/(Modular a, Modular const b) { return a /= b; }",
		"  friend std::ostream& operator<<(std::ostream& os, Modular const& a) {return os << a.value;}",
		"  friend bool operator==(Modular const& a, Modular const& b) {return a.value == b.value;}",
		"  friend bool operator!=(Modular const& a, Modular const& b) {return a.value != b.value;}",
		"};"
	],
	"description": "Modular"
	},
	"segment tree sum": {
	"prefix": "segment tree sum",
	"body": [
		"template <typename T>",
		"class segment_tree_sum {",
		"private:",
		"    typedef struct node {",
		"        int l, r;",
		"        T val, lazy;",
		"    } node;",
		"    int n;",
		"    vector<node> st;",
		"    void build(int i, int l, int r, vector<T> &a) {",
		"        st[i].l = l, st[i].r = r, st[i].lazy = 0;",
		"        if (leaf(i)) {",
		"            st[i].val = a[l];",
		"        }",
		"        else {",
		"            int mid = (l + r) / 2;",
		"            build(LC(i), l, mid, a);",
		"            build(RC(i), mid + 1, r, a);",
		"            st[i].val = st[LC(i)].val + st[RC(i)].val;",
		"        }",
		"    }",
		"    void lazy_update(int i) {",
		"        st[i].val += st[i].lazy * (st[i].r - st[i].l + 1);",
		"        if (!leaf(i)) {",
		"            st[LC(i)].lazy += st[i].lazy;",
		"            st[RC(i)].lazy += st[i].lazy;",
		"        }",
		"        st[i].lazy = 0;",
		"    }",
		"    void update(int i, int l, int r, T val) {",
		"        lazy_update(i);",
		"        if (disjoint(i, l, r)) return;",
		"        if (encompasses(i, l, r)) {",
		"            st[i].lazy += val;",
		"            lazy_update(i);",
		"            return;",
		"        }",
		"        update(LC(i), l, r, val);",
		"        update(RC(i), l, r, val);",
		"        st[i].val = st[LC(i)].val + st[RC(i)].val;",
		"    }",
		"    T query(int i, int l, int r) {",
		"        lazy_update(i);",
		"        if (disjoint(i, l, r)) return 0;",
		"        if (encompasses(i, l, r)) return st[i].val;",
		"        return query(LC(i), l, r) + query(RC(i), l, r);",
		"    }",
		"    bool encompasses(int i, int l, int r) { // Whether [l, r] encompasses the range of node i",
		"        return (st[i].l >= l && st[i].r <= r);",
		"    }",
		"    bool disjoint(int i, int l, int r) {",
		"        return (st[i].r < l || st[i].l > r);",
		"    }",
		"    bool leaf(int i) {",
		"        return (st[i].l == st[i].r);",
		"    }",
		"    int LC(int i) { // left child of node i",
		"        return 2 * i;",
		"    }",
		"    int RC(int i) { // right child of node i",
		"        return 2 * i + 1;",
		"    }",
		"public: // User functions",
		"    segment_tree_sum(vector<T> &a) {",
		"        n = a.size();",
		"        assert(n > 0);",
		"        st.resize(4 * n + 3);",
		"        build(1, 0, n - 1, a);",
		"    }",
		"    void range_increase(int l, int r, T val) { // assuming l, r are 0-indexed",
		"        assert(l >= 0 && l < n && r >= 0 && r < n && l <= r); ",
		"        update(1, l, r, val);",
		"    }",
		"    T range_sum(int l, int r) { // assuming l, r are 0-indexed",
		"        assert(l >= 0 && l < n && r >= 0 && r < n && l <= r); ",
		"        return query(1, l, r);",
		"    }",
		"};"
	],
	"description": "segment tree sum"
	},
	"segment tree max": {
	"prefix": "segment tree max",
	"body": [
		"template <typename T>",
		"class segment_tree_max {",
		"private:",
		"    typedef struct node {",
		"        int l, r;",
		"        T val, lazy;",
		"    } node;",
		"    int n;",
		"    vector<node> st;",
		"    void build(int i, int l, int r, vector<T> &a) {",
		"        st[i].l = l, st[i].r = r, st[i].lazy = 0;",
		"        if (leaf(i)) {",
		"            st[i].val = a[l];",
		"        }",
		"        else {",
		"            int mid = (l + r) / 2;",
		"            build(LC(i), l, mid, a);",
		"            build(RC(i), mid + 1, r, a);",
		"            st[i].val = max(st[LC(i)].val, st[RC(i)].val);",
		"        }",
		"    }",
		"    void lazy_update(int i) {",
		"        st[i].val += st[i].lazy;",
		"        if (!leaf(i)) {",
		"            st[LC(i)].lazy += st[i].lazy;",
		"            st[RC(i)].lazy += st[i].lazy;",
		"        }",
		"        st[i].lazy = 0;",
		"    }",
		"    void update(int i, int l, int r, T val) {",
		"        lazy_update(i);",
		"        if (disjoint(i, l, r)) return;",
		"        if (encompasses(i, l, r)) {",
		"            st[i].lazy += val;",
		"            lazy_update(i);",
		"            return;",
		"        }",
		"        update(LC(i), l, r, val);",
		"        update(RC(i), l, r, val);",
		"        st[i].val = max(st[LC(i)].val, st[RC(i)].val);",
		"    }",
		"    T query(int i, int l, int r) {",
		"        lazy_update(i);",
		"        if (disjoint(i, l, r)) return numeric_limits<T>::min();",
		"        if (encompasses(i, l, r)) return st[i].val;",
		"        return max(query(LC(i), l, r), query(RC(i), l, r));",
		"    }",
		"    bool encompasses(int i, int l, int r) { // Whether [l, r] encompasses the range of node i",
		"        return (st[i].l >= l && st[i].r <= r);",
		"    }",
		"    bool disjoint(int i, int l, int r) {",
		"        return (st[i].r < l || st[i].l > r);",
		"    }",
		"    bool leaf(int i) {",
		"        return (st[i].l == st[i].r);",
		"    }",
		"    int LC(int i) { // left child of node i",
		"        return 2 * i;",
		"    }",
		"    int RC(int i) { // right child of node i",
		"        return 2 * i + 1;",
		"    }",
		"public: // User functions",
		"    segment_tree_max(vector<T> &a) {",
		"        n = a.size();",
		"        assert(n > 0);",
		"        st.resize(4 * n + 3);",
		"        build(1, 0, n - 1, a);",
		"    }",
		"    void range_increase(int l, int r, T val) { // assuming l, r are 0-indexed",
		"        assert(l >= 0 && l < n && r >= 0 && r < n && l <= r); ",
		"        update(1, l, r, val);",
		"    }",
		"    T range_max(int l, int r) { // assuming l, r are 0-indexed",
		"        assert(l >= 0 && l < n && r >= 0 && r < n && l <= r); ",
		"        return query(1, l, r);",
		"    }",
		"};"
	],
	"description": "segment tree max"
	},
	"segment tree min": {
	"prefix": "segment tree min",
	"body": [
		"template <typename T>",
		"class segment_tree_min {",
		"private:",
		"    typedef struct node {",
		"        int l, r;",
		"        T val, lazy;",
		"    } node;",
		"    int n;",
		"    vector<node> st;",
		"    void build(int i, int l, int r, vector<T> &a) {",
		"        st[i].l = l, st[i].r = r, st[i].lazy = 0;",
		"        if (leaf(i)) {",
		"            st[i].val = a[l];",
		"        }",
		"        else {",
		"            int mid = (l + r) / 2;",
		"            build(LC(i), l, mid, a);",
		"            build(RC(i), mid + 1, r, a);",
		"            st[i].val = min(st[LC(i)].val, st[RC(i)].val);",
		"        }",
		"    }",
		"    void lazy_update(int i) {",
		"        st[i].val += st[i].lazy;",
		"        if (!leaf(i)) {",
		"            st[LC(i)].lazy += st[i].lazy;",
		"            st[RC(i)].lazy += st[i].lazy;",
		"        }",
		"        st[i].lazy = 0;",
		"    }",
		"    void update(int i, int l, int r, T val) {",
		"        lazy_update(i);",
		"        if (disjoint(i, l, r)) return;",
		"        if (encompasses(i, l, r)) {",
		"            st[i].lazy += val;",
		"            lazy_update(i);",
		"            return;",
		"        }",
		"        update(LC(i), l, r, val);",
		"        update(RC(i), l, r, val);",
		"        st[i].val = min(st[LC(i)].val, st[RC(i)].val);",
		"    }",
		"    T query(int i, int l, int r) {",
		"        lazy_update(i);",
		"        if (disjoint(i, l, r)) return numeric_limits<T>::max();",
		"        if (encompasses(i, l, r)) return st[i].val;",
		"        return min(query(LC(i), l, r), query(RC(i), l, r));",
		"    }",
		"    bool encompasses(int i, int l, int r) { // Whether [l, r] encompasses the range of node i",
		"        return (st[i].l >= l && st[i].r <= r);",
		"    }",
		"    bool disjoint(int i, int l, int r) {",
		"        return (st[i].r < l || st[i].l > r);",
		"    }",
		"    bool leaf(int i) {",
		"        return (st[i].l == st[i].r);",
		"    }",
		"    int LC(int i) { // left child of node i",
		"        return 2 * i;",
		"    }",
		"    int RC(int i) { // right child of node i",
		"        return 2 * i + 1;",
		"    }",
		"public: // User functions",
		"    segment_tree_min(vector<T> &a) {",
		"        n = a.size();",
		"        assert(n > 0);",
		"        st.resize(4 * n + 3);",
		"        build(1, 0, n - 1, a);",
		"    }",
		"    void range_increase(int l, int r, T val) { // assuming l, r are 0-indexed",
		"        assert(l >= 0 && l < n && r >= 0 && r < n && l <= r); ",
		"        update(1, l, r, val);",
		"    }",
		"    T range_min(int l, int r) { // assuming l, r are 0-indexed",
		"        assert(l >= 0 && l < n && r >= 0 && r < n && l <= r); ",
		"        return query(1, l, r);",
		"    }",
		"};"
	],
	"description": "segment tree min"
	},
	"euler tour": {
	"prefix": "euler tour",
	"body": [
		"    int n, m;",
		"    cin >> n >> m;",
		"    vector<vector<int>> edges(n);",
		"    int tmp = m;",
		"    while (tmp--) {",
		"        int u, v;",
		"        cin >> u >> v;",
		"        u--, v--;",
		"        edges[u].push_back(v);",
		"        edges[v].push_back(u);",
		"    }",
		"    map<int, int> l, r;",
		"    vector<int> lr, a;",
		"    function<void(int u, int p)> dfs = [&](int u, int p) {",
		"        l[u] = a.size();",
		"        a.push_back(u);",
		"        lr.push_back(0);",
		"        for (int v: edges[u]) if (v != p) dfs(v, u);",
		"        r[u] = a.size();",
		"        a.push_back(u);",
		"        lr.push_back(1);",
		"    };",
		"    dfs(0, -1);"
	],
	"description": "euler tour"
	},
	"Tree": {
	"prefix": "Tree",
	"body": [
		"template <typename T>",
		"class Tree {",
		"    bool doing_dfs_depths, doing_dfs_subtrees; // dfs flags for depth, subtree size calculation",
		"    bool doing_euler_tour; // dfs flag(s) for euler tour",
		"    bool doing_binary_lifting; // binary lifting",
		"    bool need_dfs_stack; // for dfs stack",
		"    bool doing_centroid_algo;",
		"    int diameter_end; // end point of diameter, where stack stops and calculates centroid",
		"    int n, m; // 0-indexed",
		"    int k; // k = __lg(n) + 1 for binary lifting",
		"    vector<vector<pair<int, T>>> adj; // weighted tree ",
		"public:",
		"    int diameter; // stores tree diameter",
		"    vector<int> centroids; // Stores the centroids of the tree",
		"    vector<int> depth, subtree; ",
		"    vector<int> start_time, finish_time, euler_tour, is_startnode; // euler tour related",
		"    vector<T> dist; // for djikstra",
		"    vector<vector<int>> up; // For binary lifting. Can potentially store more info, other than just the ancestor. Can help find path characteristics from u to v in O(logn)",
		"    vector<int> val; // tr.val[i] = value of node i, if nodes have values, we can use this.",
		"    vector<int> dfs_stack;",
		"    vector<T> in_dp; // best in_dp = max(edge + in_dp(child)) over all child",
		"    vector<T> out_dp;",
		"    vector<vector<T>> best_2_in_dp; // stores best_two(edge + in_dp(child)) over all child. Used to find out_dp",
		"    Tree(int x) {",
		"        n = x;",
		"        m = 0;",
		"        assert(n > 0);",
		"        adj.assign(n, vector<pair<int, T>> (0));",
		"        depth.clear();",
		"        subtree.clear();",
		"        start_time.clear();",
		"        finish_time.clear();",
		"        euler_tour.clear();",
		"        is_startnode.clear();",
		"        dist.clear();",
		"        up.clear();",
		"        centroids.clear();",
		"        dfs_stack.clear();",
		"        doing_centroid_algo = 0;",
		"        doing_dfs_depths = 0;",
		"        doing_dfs_subtrees = 0;",
		"        doing_euler_tour = 0;",
		"        doing_binary_lifting = 0;",
		"        need_dfs_stack = 0;",
		"    }",
		"    void add_edge(int u, int v, T w = 1) {",
		"        assert(u >= 0 && u < n && v >= 0 && v < n);",
		"        adj[u].push_back({v, w}); // Assuming undirected tree",
		"        adj[v].push_back({u, w});",
		"        m++;",
		"    }",
		"    int _dfs(int u, int p, int dep, int &cnt) { ",
		"        int sub = 1; // subtree size",
		"        if (need_dfs_stack) dfs_stack.push_back(u);",
		"        if (doing_centroid_algo && u == diameter_end) {",
		"            int tmp = dfs_stack.size();",
		"            diameter = tmp - 1;",
		"            centroids.push_back(dfs_stack[tmp / 2]);",
		"            if (tmp % 2 == 0) {",
		"                centroids.push_back(dfs_stack[tmp / 2 - 1]);",
		"            }",
		"        }",
		"        if (doing_binary_lifting) {",
		"            up[u][0] = p;",
		"            for (int j = 1; (1 << j) <= dep; j++) {",
		"                up[u][j] = up[up[u][j - 1]][j - 1];",
		"            }",
		"        }",
		"        if (doing_dfs_depths) depth[u] = dep; // flag",
		"        if (doing_euler_tour) start_time[u] = cnt++;",
		"        for (auto [v, w]: adj[u]) {",
		"            if (v == p) continue;",
		"            sub += _dfs(v, u, dep + 1, cnt); // subtree size",
		"        }",
		"        if (doing_dfs_subtrees) subtree[u] = sub; // flag",
		"        if (doing_euler_tour) finish_time[u] = cnt++;",
		"        if (need_dfs_stack) dfs_stack.pop_back();",
		"        return sub;",
		"    }",
		"    void dfs(int root, bool depths_flag = 0, bool subtrees_flag = 0, bool eulertour_flag = 0, bool binarylifting_flag = 0,",
		"            bool dfsstack_flag = 0) {",
		"        // By setting depth_flag on, you can access tr.depth[i] to get depth of ith node",
		"        assert(root >= 0 && root < n);",
		"        assert(m == n - 1);",
		"        doing_dfs_depths = depths_flag;",
		"        doing_dfs_subtrees = subtrees_flag;",
		"        doing_euler_tour = eulertour_flag; // tracks start and finish time/index of each node in tr.start_time[i]. ",
		"        doing_binary_lifting = binarylifting_flag;",
		"        need_dfs_stack = dfsstack_flag;",
		"        if (dfsstack_flag) dfs_stack.clear();",
		"        if (binarylifting_flag) {",
		"            doing_dfs_depths = 1; // if doing lca then doing depths by default",
		"            k = 32 - __builtin_clz(n);",
		"            up.assign(n, vector<int> (k, -1));",
		"        }",
		"        if (depths_flag) depth.resize(n);",
		"        if (subtrees_flag) subtree.resize(n);",
		"        if (eulertour_flag) {",
		"            start_time.resize(n);",
		"            finish_time.resize(n);",
		"        }",
		"        int cnt = 0; // tracks start/finish time of nodes for euler tour ",
		"        _dfs(root, -1, 0, cnt); // assuming root depth is 0",
		"        if (eulertour_flag) {",
		"            assert(cnt == 2 * n); // ensures euler tour is correctly calculated",
		"            euler_tour.resize(2 * n);",
		"            is_startnode.resize(2 * n); // The ith node euler tour node is a start node or a finish node ",
		"            for (int i = 0; i < n; i++) {",
		"                euler_tour[start_time[i]] = i;",
		"                is_startnode[start_time[i]] = 1;",
		"            }",
		"            for (int i = 0; i < n; i++) {",
		"                euler_tour[finish_time[i]] = i;",
		"                is_startnode[finish_time[i]] = 0;",
		"            }",
		"        }",
		"        doing_dfs_depths = doing_dfs_subtrees = doing_euler_tour = binarylifting_flag = need_dfs_stack = 0;",
		"    }",
		"    void find_centroids() {",
		"        assert(m == n - 1);",
		"        centroids.clear();",
		"        dfs(0, 1);",
		"        int end1;",
		"        int max_dep = -1;",
		"        for (int i = 0; i < n; i++) {",
		"            if (depth[i] > max_dep) {",
		"                max_dep = depth[i];",
		"                end1 = i;",
		"            }",
		"        }",
		"        dfs(end1, 1);",
		"        int end2;",
		"        max_dep = -1;",
		"        for (int i = 0; i < n; i++) {",
		"            if (depth[i] > max_dep) {",
		"                max_dep = depth[i];",
		"                end2 = i;",
		"            }",
		"        }",
		"        doing_centroid_algo = 1;",
		"        diameter_end = end2;",
		"        dfs(end1, 0, 0, 0, 0, 1); // Calculating centroids, diameter",
		"        doing_centroid_algo = 0;",
		"    }",
		"    void djikstra(int root) { // distances can be accessed as tr.dist[i]",
		"        assert(root >= 0 && root < n);",
		"        assert(m == n - 1);",
		"        dist.assign(n, numeric_limits<T>::max());",
		"        priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> pq;",
		"        pq.push({0, root});",
		"        while (!pq.empty()) {",
		"            auto [d, u] = pq.top();",
		"            pq.pop();",
		"            if (dist[u] <= d) continue;",
		"            dist[u] = d;",
		"            for (auto [v, w]: adj[u]) {",
		"                if (dist[v] > d + w) pq.push({d + w, v});",
		"            }",
		"        }",
		"    }",
		"    int lca(int u, int v) { // assuming 0-indexed",
		"        assert(up.size() == n); // Ensure that dfs is done first with binary lifting flag on",
		"        assert(depth.size() == n); // Same as above",
		"        assert(u >= 0 && u < n && v >= 0 && v < n);",
		"        if (depth[u] < depth[v]) swap(u, v);",
		"        int diff = depth[u] - depth[v];",
		"        for (int i = k - 1; i >= 0; i--) {",
		"            if (diff & (1 << i)) u = up[u][i];",
		"        }",
		"        if (u == v) return u;",
		"        for (int i = k - 1; i >= 0; i--) {",
		"            if (up[u][i] != up[v][i]) {",
		"                u = up[u][i];",
		"                v = up[v][i];",
		"            }",
		"        }",
		"        return up[u][0];",
		"    }",
		"};"
	],
	"description": "Tree"
	},
	"djikstra": {
	"prefix": "djikstra",
	"body": [
		"typedef long long ll;",
		"    typedef pair<ll, ll> ii;",
		"    typedef struct comp {",
		"        bool operator() (ii a, ii b) const {",
		"            return a > b;",
		"        }",
		"    } comp;",
		"    int n, m;",
		"    cin >> n >> m;",
		"    vector<vector<ii>> edges(n);",
		"    int tmp = m;",
		"    while (tmp--) {",
		"        int u, v, c;",
		"        cin >> u >> v >> c;",
		"        u--, v--;",
		"        edges[u].push_back({v, c});",
		"        edges[v].push_back({u, c});",
		"    }",
		"    priority_queue<ii, vector<ii>, comp> pq;",
		"    pq.push({0, 0});",
		"    vector<int> vis(n, 0);",
		"    vector<ll> dist(n, 1e18); ",
		"    while (!pq.empty()) {",
		"        auto [c, u] = pq.top();",
		"        pq.pop();",
		"        if (vis[u]) continue;",
		"        vis[u] = 1;",
		"        dist[u] = c;",
		"        for (auto [v, cost]: edges[u]) {",
		"            if (!vis[v]) pq.push({c + cost, v});",
		"        }",
		"    }"
	],
	"description": "djikstra"
	},
	"sliding window": {
	"prefix": "sliding window",
	"body": [
		"ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
		"    ll n, k;",
		"    cin >> n >> k;",
		"    vector<ll> a(n);",
		"    for (auto &x: a) cin >> x;",
		"    int r = -1;",
		"    ll sum = 0;",
		"    int ans = 0;",
		"    for (int l = 0; l < n; l++) {",
		"        if (r < l) {",
		"            r = l;",
		"            sum = a[l];",
		"        }",
		"        while (r + 1 < n && sum + a[r + 1] <= k) {",
		"            sum += a[r + 1];",
		"            r++;",
		"        }",
		"        ans = max(ans, r - l + 1);",
		"        sum -= a[l];",
		"    }",
		"    cout << ans << \"\\n\";"
	],
	"description": "sliding window"
	},
	"prefix sum 2d": {
	"prefix": "prefix sum 2d",
	"body": [
		"int n, m;",
		"    cin >> n >> m;",
		"    vector<vector<int>> a(n, vector<int> (m));",
		"    for (auto &v: a) for (auto &x: v) cin >> x;",
		"    vector<vector<ll>> p(n + 1, vector<ll> (m + 1, 0));",
		"    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) p[i][j] = a[i - 1][j - 1] + p[i - 1][j] + p[i][j - 1] - p[i - 1][j - 1];",
		"    int q;",
		"    cin >> q;",
		"    int tmp = q;",
		"    while (tmp--) {",
		"        int l1, r1, l2, r2;",
		"        cin >> l1 >> r1 >> l2 >> r2;",
		"        cout << (p[l2][r2] - p[l1 - 1][r2] - p[l2][r1 - 1] + p[l1 - 1][r1 - 1]) << \"\\n\";",
		"    }"
	],
	"description": "prefix sum 2d"
	},
	"bigint": {
	"prefix": "bigint",
	"body": [
		"const int maxn = 1e2 + 14, lg = 15;",
		"const int base = 1000000000;",
		"const int base_digits = 9;",
		"struct bigint {",
		"    vector<int> a;",
		"    int sign;",
		"    /*<arpa>*/",
		"    int size(){",
		"        if(a.empty())return 0;",
		"        int ans=(a.size()-1)*base_digits;",
		"        int ca=a.back();",
		"        while(ca)",
		"            ans++,ca/=10;",
		"        return ans;",
		"    }",
		"    bigint operator ^(const bigint &v){",
		"        bigint ans=1,a=*this,b=v;",
		"        while(!b.isZero()){",
		"            if(b%2)",
		"                ans*=a;",
		"            a*=a,b/=2;",
		"        }",
		"        return ans;",
		"    }",
		"    string to_string(){",
		"        stringstream ss;",
		"        ss << *this;",
		"        string s;",
		"        ss >> s;",
		"        return s;",
		"    }",
		"    int sumof(){",
		"        string s = to_string();",
		"        int ans = 0;",
		"        for(auto c : s)  ans += c - '0';",
		"        return ans;",
		"    }",
		"    /*</arpa>*/",
		"    bigint() :",
		"        sign(1) {",
		"    }",
		"",
		"    bigint(long long v) {",
		"        *this = v;",
		"    }",
		"",
		"    bigint(const string &s) {",
		"        read(s);",
		"    }",
		"",
		"    void operator=(const bigint &v) {",
		"        sign = v.sign;",
		"        a = v.a;",
		"    }",
		"",
		"    void operator=(long long v) {",
		"        sign = 1;",
		"        a.clear();",
		"        if (v < 0)",
		"            sign = -1, v = -v;",
		"        for (; v > 0; v = v / base)",
		"            a.push_back(v % base);",
		"    }",
		"",
		"    bigint operator+(const bigint &v) const {",
		"        if (sign == v.sign) {",
		"            bigint res = v;",
		" ",
		"            for (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) || carry; ++i) {",
		"                if (i == (int) res.a.size())",
		"                    res.a.push_back(0);",
		"                res.a[i] += carry + (i < (int) a.size() ? a[i] : 0);",
		"                carry = res.a[i] >= base;",
		"                if (carry)",
		"                    res.a[i] -= base;",
		"            }",
		"            return res;",
		"        }",
		"        return *this - (-v);",
		"    }",
		" ",
		"    bigint operator-(const bigint &v) const {",
		"        if (sign == v.sign) {",
		"            if (abs() >= v.abs()) {",
		"                bigint res = *this;",
		"                for (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) {",
		"                    res.a[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);",
		"                    carry = res.a[i] < 0;",
		"                    if (carry)",
		"                        res.a[i] += base;",
		"                }",
		"                res.trim();",
		"                return res;",
		"            }",
		"            return -(v - *this);",
		"        }",
		"        return *this + (-v);",
		"    }",
		" ",
		"    void operator*=(int v) {",
		"        if (v < 0)",
		"            sign = -sign, v = -v;",
		"        for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {",
		"            if (i == (int) a.size())",
		"                a.push_back(0);",
		"            long long cur = a[i] * (long long) v + carry;",
		"            carry = (int) (cur / base);",
		"            a[i] = (int) (cur % base);",
		"            //asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));",
		"        }",
		"        trim();",
		"    }",
		" ",
		"    bigint operator*(int v) const {",
		"        bigint res = *this;",
		"        res *= v;",
		"        return res;",
		"    }",
		" ",
		"    void operator*=(long long v) {",
		"        if (v < 0)",
		"            sign = -sign, v = -v;",
		"        if(v > base){",
		"            *this = *this * (v / base) * base + *this * (v % base);",
		"            return ;",
		"        }",
		"        for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {",
		"            if (i == (int) a.size())",
		"                a.push_back(0);",
		"            long long cur = a[i] * (long long) v + carry;",
		"            carry = (int) (cur / base);",
		"            a[i] = (int) (cur % base);",
		"            //asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));",
		"        }",
		"        trim();",
		"    }",
		" ",
		"    bigint operator*(long long v) const {",
		"        bigint res = *this;",
		"        res *= v;",
		"        return res;",
		"    }",
		" ",
		"    friend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {",
		"        int norm = base / (b1.a.back() + 1);",
		"        bigint a = a1.abs() * norm;",
		"        bigint b = b1.abs() * norm;",
		"        bigint q, r;",
		"        q.a.resize(a.a.size());",
		" ",
		"        for (int i = a.a.size() - 1; i >= 0; i--) {",
		"            r *= base;",
		"            r += a.a[i];",
		"            int s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];",
		"            int s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];",
		"            int d = ((long long) base * s1 + s2) / b.a.back();",
		"            r -= b * d;",
		"            while (r < 0)",
		"                r += b, --d;",
		"            q.a[i] = d;",
		"        }",
		" ",
		"        q.sign = a1.sign * b1.sign;",
		"        r.sign = a1.sign;",
		"        q.trim();",
		"        r.trim();",
		"        return make_pair(q, r / norm);",
		"    }",
		" ",
		"    bigint operator/(const bigint &v) const {",
		"        return divmod(*this, v).first;",
		"    }",
		" ",
		"    bigint operator%(const bigint &v) const {",
		"        return divmod(*this, v).second;",
		"    }",
		" ",
		"    void operator/=(int v) {",
		"        if (v < 0)",
		"            sign = -sign, v = -v;",
		"        for (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) {",
		"            long long cur = a[i] + rem * (long long) base;",
		"            a[i] = (int) (cur / v);",
		"            rem = (int) (cur % v);",
		"        }",
		"        trim();",
		"    }",
		" ",
		"    bigint operator/(int v) const {",
		"        bigint res = *this;",
		"        res /= v;",
		"        return res;",
		"    }",
		" ",
		"    int operator%(int v) const {",
		"        if (v < 0)",
		"            v = -v;",
		"        int m = 0;",
		"        for (int i = a.size() - 1; i >= 0; --i)",
		"            m = (a[i] + m * (long long) base) % v;",
		"        return m * sign;",
		"    }",
		" ",
		"    void operator+=(const bigint &v) {",
		"        *this = *this + v;",
		"    }",
		"    void operator-=(const bigint &v) {",
		"        *this = *this - v;",
		"    }",
		"    void operator*=(const bigint &v) {",
		"        *this = *this * v;",
		"    }",
		"    void operator/=(const bigint &v) {",
		"        *this = *this / v;",
		"    }",
		" ",
		"    bool operator<(const bigint &v) const {",
		"        if (sign != v.sign)",
		"            return sign < v.sign;",
		"        if (a.size() != v.a.size())",
		"            return a.size() * sign < v.a.size() * v.sign;",
		"        for (int i = a.size() - 1; i >= 0; i--)",
		"            if (a[i] != v.a[i])",
		"                return a[i] * sign < v.a[i] * sign;",
		"        return false;",
		"    }",
		" ",
		"    bool operator>(const bigint &v) const {",
		"        return v < *this;",
		"    }",
		"    bool operator<=(const bigint &v) const {",
		"        return !(v < *this);",
		"    }",
		"    bool operator>=(const bigint &v) const {",
		"        return !(*this < v);",
		"    }",
		"    bool operator==(const bigint &v) const {",
		"        return !(*this < v) && !(v < *this);",
		"    }",
		"    bool operator!=(const bigint &v) const {",
		"        return *this < v || v < *this;",
		"    }",
		" ",
		"    void trim() {",
		"        while (!a.empty() && !a.back())",
		"            a.pop_back();",
		"        if (a.empty())",
		"            sign = 1;",
		"    }",
		" ",
		"    bool isZero() const {",
		"        return a.empty() || (a.size() == 1 && !a[0]);",
		"    }",
		" ",
		"    bigint operator-() const {",
		"        bigint res = *this;",
		"        res.sign = -sign;",
		"        return res;",
		"    }",
		" ",
		"    bigint abs() const {",
		"        bigint res = *this;",
		"        res.sign *= res.sign;",
		"        return res;",
		"    }",
		" ",
		"    long long longValue() const {",
		"        long long res = 0;",
		"        for (int i = a.size() - 1; i >= 0; i--)",
		"            res = res * base + a[i];",
		"        return res * sign;",
		"    }",
		" ",
		"    friend bigint gcd(const bigint &a, const bigint &b) {",
		"        return b.isZero() ? a : gcd(b, a % b);",
		"    }",
		"    friend bigint lcm(const bigint &a, const bigint &b) {",
		"        return a / gcd(a, b) * b;",
		"    }",
		" ",
		"    void read(const string &s) {",
		"        sign = 1;",
		"        a.clear();",
		"        int pos = 0;",
		"        while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {",
		"            if (s[pos] == '-')",
		"                sign = -sign;",
		"            ++pos;",
		"        }",
		"        for (int i = s.size() - 1; i >= pos; i -= base_digits) {",
		"            int x = 0;",
		"            for (int j = max(pos, i - base_digits + 1); j <= i; j++)",
		"                x = x * 10 + s[j] - '0';",
		"            a.push_back(x);",
		"        }",
		"        trim();",
		"    }",
		" ",
		"    friend istream& operator>>(istream &stream, bigint &v) {",
		"        string s;",
		"        stream >> s;",
		"        v.read(s);",
		"        return stream;",
		"    }",
		" ",
		"    friend ostream& operator<<(ostream &stream, const bigint &v) {",
		"        if (v.sign == -1)",
		"            stream << '-';",
		"        stream << (v.a.empty() ? 0 : v.a.back());",
		"        for (int i = (int) v.a.size() - 2; i >= 0; --i)",
		"            stream << setw(base_digits) << setfill('0') << v.a[i];",
		"        return stream;",
		"    }",
		" ",
		"    static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {",
		"        vector<long long> p(max(old_digits, new_digits) + 1);",
		"        p[0] = 1;",
		"        for (int i = 1; i < (int) p.size(); i++)",
		"            p[i] = p[i - 1] * 10;",
		"        vector<int> res;",
		"        long long cur = 0;",
		"        int cur_digits = 0;",
		"        for (int i = 0; i < (int) a.size(); i++) {",
		"            cur += a[i] * p[cur_digits];",
		"            cur_digits += old_digits;",
		"            while (cur_digits >= new_digits) {",
		"                res.push_back(int(cur % p[new_digits]));",
		"                cur /= p[new_digits];",
		"                cur_digits -= new_digits;",
		"            }",
		"        }",
		"        res.push_back((int) cur);",
		"        while (!res.empty() && !res.back())",
		"            res.pop_back();",
		"        return res;",
		"    }",
		" ",
		"    typedef vector<long long> vll;",
		" ",
		"    static vll karatsubaMultiply(const vll &a, const vll &b) {",
		"        int n = a.size();",
		"        vll res(n + n);",
		"        if (n <= 32) {",
		"            for (int i = 0; i < n; i++)",
		"                for (int j = 0; j < n; j++)",
		"                    res[i + j] += a[i] * b[j];",
		"            return res;",
		"        }",
		" ",
		"        int k = n >> 1;",
		"        vll a1(a.begin(), a.begin() + k);",
		"        vll a2(a.begin() + k, a.end());",
		"        vll b1(b.begin(), b.begin() + k);",
		"        vll b2(b.begin() + k, b.end());",
		" ",
		"        vll a1b1 = karatsubaMultiply(a1, b1);",
		"        vll a2b2 = karatsubaMultiply(a2, b2);",
		" ",
		"        for (int i = 0; i < k; i++)",
		"            a2[i] += a1[i];",
		"        for (int i = 0; i < k; i++)",
		"            b2[i] += b1[i];",
		" ",
		"        vll r = karatsubaMultiply(a2, b2);",
		"        for (int i = 0; i < (int) a1b1.size(); i++)",
		"            r[i] -= a1b1[i];",
		"        for (int i = 0; i < (int) a2b2.size(); i++)",
		"            r[i] -= a2b2[i];",
		" ",
		"        for (int i = 0; i < (int) r.size(); i++)",
		"            res[i + k] += r[i];",
		"        for (int i = 0; i < (int) a1b1.size(); i++)",
		"            res[i] += a1b1[i];",
		"        for (int i = 0; i < (int) a2b2.size(); i++)",
		"            res[i + n] += a2b2[i];",
		"        return res;",
		"    }",
		" ",
		"    bigint operator*(const bigint &v) const {",
		"        vector<int> a6 = convert_base(this->a, base_digits, 6);",
		"        vector<int> b6 = convert_base(v.a, base_digits, 6);",
		"        vll a(a6.begin(), a6.end());",
		"        vll b(b6.begin(), b6.end());",
		"        while (a.size() < b.size())",
		"            a.push_back(0);",
		"        while (b.size() < a.size())",
		"            b.push_back(0);",
		"        while (a.size() & (a.size() - 1))",
		"            a.push_back(0), b.push_back(0);",
		"        vll c = karatsubaMultiply(a, b);",
		"        bigint res;",
		"        res.sign = sign * v.sign;",
		"        for (int i = 0, carry = 0; i < (int) c.size(); i++) {",
		"            long long cur = c[i] + carry;",
		"            res.a.push_back((int) (cur % 1000000));",
		"            carry = (int) (cur / 1000000);",
		"        }",
		"        res.a = convert_base(res.a, 6, base_digits);",
		"        res.trim();",
		"        return res;",
		"    }",
		"};",
		"/*",
		"The bigint class can handle arbitrarily large integers by dynamically allocating memory for the digits.",
		"So it is only limited by the amount of available memory.",
		"The number is stored in a vector, with 1 element corresponding to 9 digits.",
		"So if there are n digits, the memory would be n / 9 ints.  ",
		"--Arithmetic Operators",
		"+, -, *, /, %, ^",
		"+, - are O(max(n, m)) where n, m are the number of digits ",
		"*, /, % are O(n * m)",
		"^ (exponentiation) is O(log(p)*n^2) where n is no. of digits in the base and p is the power",
		"Note: Use karatsuba multiplication, whose time complexity is O(n^1.585), where n is no. of digits",
		"--Comparison Operators",
		"==, !=, >, <",
		"All are O(n)",
		"--Utility Operations",
		".sumof() - returns sum of digits - O(n)",
		".abs() - returns absolute value - O(1)",
		".to_string() - returns the string representation - O(n)",
		"gcd(a, b) - returns the gcd - O(n * log(m)), where n, m are the no. of digits in a, b",
		".isZero() - O(1) ",
		"negation - returns -a; for example bigint b = -a; // a is a bigint ",
		"--IO",
		"cout << ",
		"cin >> ",
		"are supported in O(n)",
		"*/"
	],
	"description": "bigint"
	},
	"sieve": {
	"prefix": "sieve",
	"body": [
	"    int n;",
	"    cin >> n;",
	"    // list all primes <= n",
	"    vector<int> prime(n + 1, 1);",
	"    prime[0] = 0;",
	"    prime[1] = 0;",
	"    for (int i = 2; i <= n; i++) {",
	"        if (prime[i]) {",
	"            for (int j = 2 * i; j <= n; j += i) {",
	"                prime[j] = 0;",
	"            }",
	"        }",
	"    }",
	"    for (int i = 2; i <= n; i++) if (prime[i]) cout << i << \" \";",
	"    cout << \"\\n\";"
	],
	"description": "sieve"
	},
	"segmented sieve": {
	"prefix": "segmented sieve",
	"body": [
	"    ll a, b;",
	"    cin >> a >> b;",
	"    // List all primes in the range [a, b]",
	"    ll x = ceil(sqrtl(b));",
	"    unordered_set<ll> primes, st;",
	"    for (ll i = 2; i <= x; i++) {",
	"        primes.insert(i);",
	"    }",
	"    for (ll i = 2; i <= x; i++) {",
	"        if (primes.count(i) != 0) {",
	"            for (ll j = i * 2; j <= x; j += i) {",
	"                primes.erase(j);",
	"            }",
	"        }",
	"    }",
	"    for (ll i = a; i <= b; i++) {",
	"        st.insert(i);",
	"    }",
	"    for (ll z: primes) {",
	"        for (ll j = (a / z) * z; j <= b; j += z) {",
	"            if (j < a) continue;",
	"            if (j != z) st.erase(j);",
	"        }",
	"    }",
	"    for (auto m: st) cout << m << \" \";",
	"    cout << \"\\n\";"
	],
	"description": "segmented sieve"
	},
	"rolling hash 2": {
	"prefix": "rolling hash 2",
	"body": [
		"int be(int a, int b) {",
		"    int ans = 1;",
		"    while (b > 0) {",
		"        if (b & 1) ans = (1ll * ans * a) % mod;",
		"        a = (1ll * a * a) % mod;",
		"        b >>= 1;",
		"    }",
		"    return ans;",
		"}",
		"",
		"int main(void) {",
		"    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
		"",
		"    string s, t;",
		"    cin >> s >> t;",
		"    int n = s.size(), m = t.size();",
		"    int p = 97;",
		"    vector<int> pre(n);",
		"    for (int i = 0; i < n; i++) {",
		"        int tmp = s[i] - 'a' + 1;",
		"        int tmp2 = be(p, i);",
		"        pre[i] = (1ll * tmp * tmp2) % mod;",
		"        if (i > 0) pre[i] = (0ll + pre[i] + pre[i - 1]) % mod;",
		"    }",
		"    int sum = 0;",
		"    for (int i = 0; i < m; i++) {",
		"        int tmp = t[i] - 'a' + 1;",
		"        int tmp2 = be(p, i);",
		"        tmp = (1ll * tmp * tmp2) % mod;",
		"        sum = (0ll + tmp + sum) % mod;",
		"    }",
		"    for (int i = 0; i + m - 1 < n; i++) {",
		"        int x = pre[i + m - 1];",
		"        if (i > 0) x -= pre[i - 1];",
		"        if (x < 0) x += mod;",
		"        // x /= p^i",
		"        int tmp = be(p, i);",
		"        tmp = be(tmp, mod - 2);",
		"        x = (1ll * x * tmp) % mod;",
		"        if (x == sum) {",
		"            cout << \"1\\n\";",
		"            return 0;",
		"        }",
		"    }",
		"    cout << \"0\\n\";",
		"}"
	],
	"description": "rolling hash 2"
	}
}